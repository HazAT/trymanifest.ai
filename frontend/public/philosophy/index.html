<!DOCTYPE html>
<html lang="en">
<head>
  <title>Manifest — Philosophy</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&family=Instrument+Serif&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
  <style type="text/tailwindcss">
    @theme {
      --color-terminal: #00ff41;
      --color-terminal-dim: #00cc33;
      --color-amber: #ffb000;
      --color-amber-dim: #cc8d00;
      --font-mono: 'JetBrains Mono', ui-monospace, monospace;
    }
  </style>
  <style>
    * { font-family: 'JetBrains Mono', ui-monospace, monospace; }
    html { scroll-behavior: smooth; }
    body { background: #000; color: #b0b0b0; }
    ::selection { background: #00ff41; color: #000; }



    /* Blinking cursor */
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }
    .cursor::after {
      content: '';
      display: inline-block;
      width: 0.65em;
      height: 1em;
      background: #00ff41;
      vertical-align: -0.15em;
      margin-left: 1px;
      animation: blink 1s step-end infinite;
    }

    /* Fade up on scroll */
    .reveal {
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.6s ease, transform 0.6s ease;
    }
    .reveal.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* Glow effects with scanline overlay */
    .glow, .glow-amber {
      position: relative;
      display: inline-block;
    }
    .glow { text-shadow: 0 0 10px rgba(0, 255, 65, 0.3), 0 0 40px rgba(0, 255, 65, 0.1); }
    .glow-amber { text-shadow: 0 0 10px rgba(255, 176, 0, 0.3), 0 0 40px rgba(255, 176, 0, 0.1); }
    .glow::after, .glow-amber::after {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: repeating-linear-gradient(
        0deg, transparent, transparent 2px,
        rgba(0, 0, 0, 0.08) 2px, rgba(0, 0, 0, 0.08) 4px
      );
    }

    /* Code highlight bar */
    .code-line {
      border-left: 2px solid #1a1a1a;
      transition: border-color 0.3s ease;
    }
    .code-line:hover {
      border-color: #00ff41;
      background: rgba(0, 255, 65, 0.03);
    }

    /* Section dividers */
    .divider {
      height: 1px;
      background: linear-gradient(90deg, transparent, #1a1a1a 20%, #1a1a1a 80%, transparent);
    }
  </style>
</head>
<body class="min-h-screen">

  <nav class="fixed top-0 left-0 right-0 z-50 px-6 py-5" style="background: linear-gradient(to bottom, #000 0%, #000 40%, transparent 100%);">
    <div class="max-w-3xl mx-auto flex items-center justify-between">
      <a href="/" class="text-xs text-neutral-500 hover:text-terminal transition-colors cursor-pointer">
        <span class="text-terminal-dim">←</span> Manifest
      </a>
      <div class="flex items-center gap-6">
        <a href="/philosophy" class="text-xs text-neutral-600 hover:text-terminal transition-colors cursor-pointer">Philosophy</a>
        <a href="/workflow" class="text-xs text-neutral-600 hover:text-terminal transition-colors cursor-pointer">Workflow</a>
        <a href="https://github.com/HazAT/manifest" class="text-xs text-neutral-600 hover:text-terminal transition-colors cursor-pointer">GitHub</a>
      </div>
    </div>
  </nav>

  <!-- ════════════════ TITLE ════════════════ -->
  <section class="pt-24 sm:pt-32 pb-16 px-6">
    <div class="max-w-3xl mx-auto">
      <div class="text-xs text-neutral-600 tracking-wider mb-8">
        <span class="text-terminal-dim">~</span><span class="text-neutral-600">/manifest $</span> <span class="text-neutral-500">cat PHILOSOPHY.md</span>
      </div>

      <h1 class="text-3xl sm:text-4xl font-bold text-terminal glow leading-tight tracking-tight mb-6">
        An experiment
      </h1>

      <p class="text-sm sm:text-base leading-relaxed text-neutral-400">
        Manifest is an idea first, a framework second. This is an honest look at what we're exploring and why we think it's worth trying.
      </p>
    </div>
  </section>

  <div class="divider mx-6"></div>

  <!-- ════════════════ THE QUESTION ════════════════ -->
  <section class="py-16 sm:py-20 px-6">
    <div class="max-w-3xl mx-auto reveal">
      <h2 class="text-xl sm:text-2xl font-bold text-white mb-8 leading-tight">
        A question worth <span class="text-terminal glow">asking</span>
      </h2>

      <div class="space-y-6 text-sm sm:text-base leading-relaxed">
        <p>
          Agents are writing more and more of our code. Not autocomplete — actual implementation. Reading codebases, understanding intent, building features end to end. This is happening now, and it's accelerating.
        </p>

        <p>
          Which raises a question nobody has a definitive answer to: <span class="text-white">what should a framework look like if agents are the primary authors?</span>
        </p>

        <p>
          Every framework that exists today was designed for human readers. That made perfect sense — humans were the ones writing and reading the code. But as that changes, is there a better foundation? One designed around how agents actually work?
        </p>

        <p class="text-white">
          Manifest is our attempt to find out.
        </p>

        <p>
          Maybe this is the right approach. Maybe it's not. Maybe agent-first is a category that matters, or maybe agents will get good enough that it doesn't. We don't know yet. <span class="text-white">The only way to find out is to build it and see how far it goes.</span>
        </p>
      </div>
    </div>
  </section>

  <div class="divider mx-6"></div>

  <!-- ════════════════ THE OBSERVATION ════════════════ -->
  <section class="py-16 sm:py-20 px-6">
    <div class="max-w-3xl mx-auto reveal">
      <h2 class="text-xl sm:text-2xl font-bold text-white mb-8 leading-tight">
        What we <span class="text-amber glow-amber">noticed</span>
      </h2>

      <div class="space-y-6 text-sm sm:text-base leading-relaxed">
        <p>
          When you watch agents work with existing frameworks, patterns emerge. They struggle with the same things humans struggle with — but for different reasons.
        </p>

        <p>
          Middleware chains. Decorator-based dependency injection. File-system routing conventions. Auto-discovery. Lifecycle hooks. Convention over configuration taken so far that understanding a single request requires knowing the framework by heart.
        </p>

        <p>
          Humans deal with this through years of experience and intuition. Agents deal with it by burning context tokens on abstractions they can't see, or by guessing at behavior they can't verify.
        </p>

        <p>
          So we started wondering: <span class="text-white">what if the framework was just... explicit?</span> What if every behavior was visible in the code? What if an agent — or a human — could read one file and understand one complete thing?
        </p>

        <div class="bg-neutral-950 border border-neutral-800 rounded p-4 sm:p-6 my-8 space-y-2 text-sm">
          <div class="code-line pl-4 py-1"><span class="text-amber">Hidden behavior</span> makes agents guess. What if nothing was hidden?</div>
          <div class="code-line pl-4 py-1"><span class="text-amber">Scattered logic</span> loses context. What if one file = one behavior?</div>
          <div class="code-line pl-4 py-1"><span class="text-amber">Framework knowledge</span> can't be assumed. What if you could just read it?</div>
          <div class="code-line pl-4 py-1 text-white"><span class="text-terminal">These are hypotheses, not conclusions.</span></div>
        </div>

        <p class="text-neutral-500 text-sm">
          An interesting side effect: optimizing for agent comprehension seems to produce code that's easier for humans to read too. That might be a signal — or just a coincidence. We're still figuring it out.
        </p>
      </div>
    </div>
  </section>

  <div class="divider mx-6"></div>

  <!-- ════════════════ THE EXPERIMENT ════════════════ -->
  <section class="py-16 sm:py-20 px-6">
    <div class="max-w-3xl mx-auto reveal">
      <h2 class="text-xl sm:text-2xl font-bold text-white mb-8 leading-tight">
        The <span class="text-terminal glow">experiment</span>
      </h2>

      <div class="space-y-6 text-sm sm:text-base leading-relaxed">
        <p>
          Manifest is, first and foremost, an idea: <span class="text-white">what happens when you design a framework around agent comprehension instead of human convention?</span>
        </p>

        <p>
          The framework itself is one take on that idea. It's a TypeScript framework running on Bun — that part is normal. What's different is the design constraint: every line of code should be readable by an agent with zero framework-specific knowledge.
        </p>

        <p>
          One feature, one file. A feature declares its route, inputs, authentication, side effects, error cases, and business logic in a single <code class="text-terminal text-xs">defineFeature()</code> call. The entire framework is ~1,400 lines of source code that ships inside your project — not as an npm package. Small enough that an agent reads it once and understands the whole thing.
        </p>

        <p>
          No hidden functionality. No middleware. No decorators. No dependency injection. No file-system routing. If something happens, it's because the code says so.
        </p>

        <p class="text-neutral-500 text-sm">
          These are our bets. They might be the right ones, or they might be constraints that don't matter as much as we think.
        </p>

        <p class="mt-4">
          The honest truth: <span class="text-white">we don't know how complex you can go with this approach.</span> Can you build a simple API? Yes, easily. Can you build something with fifty features, multiple databases, real-time streaming, and background jobs? That's what we're trying to find out.
        </p>

        <p>
          Every project built with Manifest pushes the boundary a little further. Some things work beautifully. Some things reveal gaps. The framework evolves from what we learn — and because it ships as source code, you evolve it too.
        </p>

        <p>
          What Manifest does ask is that you <span class="text-white">try a different way of thinking about software.</span> Not "learn a new framework" — the framework is small, your agent reads it in seconds. The shift is in how you approach the work: writing code that's meant to be read by something other than you, declaring intent explicitly, keeping behavior visible. That's a mindset change, not a tooling change. It might click. It might not. The only way to know is to try.
        </p>
      </div>
    </div>
  </section>

  <div class="divider mx-6"></div>

  <!-- ════════════════ HOW FAR CAN IT GO ════════════════ -->
  <section class="py-16 sm:py-20 px-6">
    <div class="max-w-3xl mx-auto reveal">
      <h2 class="text-xl sm:text-2xl font-bold text-white mb-8 leading-tight">
        How far can <span class="text-amber glow-amber">this go?</span>
      </h2>

      <div class="space-y-6 text-sm sm:text-base leading-relaxed">
        <p>
          The experiment doesn't stop at "agents can read the code." The deeper question is: <span class="text-white">can agents own the entire lifecycle?</span> Not just writing — building, monitoring, fixing, evolving.
        </p>

        <div class="bg-neutral-950 border border-neutral-800 rounded p-4 sm:p-6 my-8 space-y-3 text-sm">
          <div class="code-line pl-4 py-1"><span class="text-terminal">Development.</span> <span class="text-neutral-500">Agents read your codebase and build features on top of it.</span></div>
          <div class="code-line pl-4 py-1"><span class="text-terminal">Onboarding.</span> <span class="text-neutral-500">Spark walks you through setup — an agent bootstrapping your project.</span></div>
          <div class="code-line pl-4 py-1"><span class="text-terminal">Refactoring.</span> <span class="text-neutral-500">The framework is source code. Agents evolve it alongside your app.</span></div>
          <div class="code-line pl-4 py-1"><span class="text-terminal">Monitoring.</span> <span class="text-neutral-500">Spark watches your running application, catches errors, acts on your behalf.</span></div>
          <div class="code-line pl-4 py-1"><span class="text-terminal">Self-healing.</span> <span class="text-neutral-500">Error fires → agent reads the feature → fixes it → Bun hot-reloads → next request works.</span></div>
        </div>

        <p>
          The self-healing loop is the most ambitious bet. An error occurs. The agent reads <code class="text-terminal text-xs">AGENTS.md</code> to orient itself. It reads the feature file — one file, complete behavior. It diagnoses the issue, edits the code, and Bun hot-reloads the module. No deploy. No restart. The next request runs the new code.
        </p>

        <p>
          Does it work? Sometimes, remarkably well. Sometimes, not at all. The design decisions — one file per feature, declared side effects, source-code framework, no hidden behavior — exist to make it <em>possible</em>. Whether it's practical at scale is something we're actively learning.
        </p>

        <p>
          That's the nature of this experiment. We're not presenting a finished product. We're exploring a design space and sharing what we find along the way.
        </p>
      </div>
    </div>
  </section>

  <div class="divider mx-6"></div>

  <!-- ════════════════ WHY TRY ════════════════ -->
  <section class="py-16 sm:py-20 px-6">
    <div class="max-w-3xl mx-auto reveal">
      <h2 class="text-xl sm:text-2xl font-bold text-white mb-8 leading-tight">
        Why <span class="text-terminal glow">try</span>
      </h2>

      <div class="space-y-6 text-sm sm:text-base leading-relaxed">
        <p>
          Manifest works today. Features, validation, routing, testing, frontend, streaming, rate limiting, database integration, Docker deployment. You can build real things with it. Spark watches your app and fixes what breaks. That part is solid.
        </p>

        <p>
          But we're not claiming this is the future of software. <span class="text-white">We're claiming it's an idea worth testing.</span>
        </p>

        <p>
          Maybe agent-first frameworks become a real category. Maybe existing frameworks adapt and the distinction stops mattering. Maybe the constraints we chose are the wrong ones. We genuinely don't know — and anyone who tells you they do is selling something.
        </p>

        <p>
          What we do know is that the question is interesting enough to build toward an answer. Every project that uses Manifest teaches us something about where this approach works, where it breaks, and what agents actually need from the code they work with.
        </p>

        <p class="text-white">
          This is for people who are curious about the same question.
        </p>

        <p>
          Not everyone will be. If your team has deep Rails expertise and it serves you well, keep using Rails. If Next.js gives you what you need, use Next.js. We're not here to tell you your tools are wrong. We're exploring a different set of trade-offs and sharing what we learn.
        </p>

        <p class="text-amber text-sm mt-8">
          Fork it. Read the code. Try building something. See if the idea resonates — or if it doesn't.
        </p>
      </div>
    </div>
  </section>

  <div class="divider mx-6"></div>

  <!-- ════════════════ CTA ════════════════ -->
  <section class="py-16 sm:py-20 px-6">
    <div class="max-w-3xl mx-auto text-center reveal">
      <div class="flex flex-col sm:flex-row items-center justify-center gap-4 sm:gap-6">
        <a href="/" class="group inline-flex items-center gap-2 bg-terminal text-black font-bold text-sm px-6 py-3 rounded hover:bg-terminal-dim transition-colors cursor-pointer">
          <span>←</span> Back to Manifest
        </a>
        <a href="https://github.com/HazAT/manifest" class="inline-flex items-center gap-2 border border-neutral-700 text-neutral-400 font-medium text-sm px-6 py-3 rounded hover:border-terminal hover:text-terminal transition-colors cursor-pointer">
          View on GitHub
        </a>
      </div>

      <p class="mt-10 text-xs text-neutral-600">
        Open source. MIT license. Read every line.
      </p>
    </div>
  </section>

  <footer class="py-12 px-6 text-center">
    <div class="max-w-3xl mx-auto flex flex-col sm:flex-row items-center justify-between gap-4">
      <span class="text-xs text-neutral-700">manifest v0.1 — the agent framework · built with <a href="https://github.com/badlogic/pi-mono/tree/main/packages/coding-agent" class="hover:text-terminal transition-colors cursor-pointer">pi</a> using manifest</span>
      <div class="flex items-center gap-6">
        <a href="/workflow" class="text-xs text-neutral-700 hover:text-terminal transition-colors cursor-pointer">Workflow</a>
        <a href="/philosophy" class="text-xs text-neutral-700 hover:text-terminal transition-colors cursor-pointer">Philosophy</a>
        <a href="https://github.com/HazAT/manifest" class="text-xs text-neutral-700 hover:text-terminal transition-colors cursor-pointer">GitHub</a>
      </div>
    </div>
  </footer>

  <!-- Dev reload -->
  <script>
    if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
      const source = new EventSource('/__dev/reload');
      source.addEventListener('reload', () => location.reload());
    }
  </script>

  <!-- Scroll reveal observer -->
  <script>
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
        }
      });
    }, { threshold: 0.15 });
    document.querySelectorAll('.reveal').forEach(el => observer.observe(el));
  </script>
</body>
</html>