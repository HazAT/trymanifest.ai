<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>‚ö° Spark</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'JetBrains Mono', ui-monospace, monospace; }

  ::selection { background: #00ff41; color: #000; }

  body {
    background: #000;
    color: #b0b0b0;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    font-size: 13px;
    line-height: 1.5;
  }

  /* Glow effects */
  .glow {
    position: relative;
    display: inline-block;
    text-shadow: 0 0 10px rgba(0, 255, 65, 0.3), 0 0 40px rgba(0, 255, 65, 0.1);
  }
  .glow::after {
    content: '';
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 0, 0, 0.08) 2px, rgba(0, 0, 0, 0.08) 4px);
  }

  .glow-amber {
    position: relative;
    display: inline-block;
    text-shadow: 0 0 10px rgba(255, 176, 0, 0.3), 0 0 40px rgba(255, 176, 0, 0.1);
  }
  .glow-amber::after {
    content: '';
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 0, 0, 0.08) 2px, rgba(0, 0, 0, 0.08) 4px);
  }

  /* Spark shimmer */
  @keyframes spark-shimmer {
    0%, 100% {
      text-shadow: 0 0 4px rgba(255, 176, 0, 0.4), 0 0 11px rgba(255, 176, 0, 0.2), 0 0 30px rgba(255, 140, 0, 0.1);
    }
    50% {
      text-shadow: 0 0 6px rgba(255, 176, 0, 0.8), 0 0 20px rgba(255, 176, 0, 0.4), 0 0 45px rgba(255, 140, 0, 0.2), 0 0 80px rgba(255, 100, 0, 0.1);
    }
  }

  .spark-word {
    color: #ffb000;
    animation: spark-shimmer 3s ease-in-out infinite;
    position: relative;
    display: inline-block;
  }
  .spark-word::before, .spark-word::after {
    content: '';
    position: absolute;
    width: 3px;
    height: 3px;
    border-radius: 50%;
    background: #ffb000;
    opacity: 0;
  }
  @keyframes ember-rise-1 {
    0% { opacity: 0; transform: translate(0, 0) scale(1); }
    20% { opacity: 1; }
    100% { opacity: 0; transform: translate(8px, -30px) scale(0); }
  }
  @keyframes ember-rise-2 {
    0% { opacity: 0; transform: translate(0, 0) scale(1); }
    25% { opacity: 0.8; }
    100% { opacity: 0; transform: translate(-6px, -25px) scale(0); }
  }
  .spark-word::before { right: 8px; top: 6px; animation: ember-rise-1 4s ease-out 1s infinite; }
  .spark-word::after { right: 2px; top: 10px; animation: ember-rise-2 4s ease-out 2.5s infinite; }

  /* Blinking cursor */
  @keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  /* Header */
  #header {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px 16px;
    background: #000;
    border-bottom: 1px solid #1a1a1a;
    flex-shrink: 0;
    min-height: 40px;
  }

  #header .logo {
    font-weight: 700;
    font-size: 15px;
    color: #ffb000;
    display: flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
  }

  .badge {
    font-size: 10px;
    padding: 2px 8px;
    border-radius: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-weight: 600;
  }

  .badge-env {
    background: #0a0a0a;
    color: #00ff41;
    border: 1px solid rgba(0, 255, 65, 0.2);
  }

  .badge-mode {
    background: #0a0a0a;
    color: #ffb000;
    border: 1px solid rgba(255, 176, 0, 0.2);
  }

  .spacer { flex: 1; }

  .status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .status-dot.connected { background: #22c55e; }
  .status-dot.disconnected { background: #ef4444; }
  .status-dot.connecting { background: #ffb000; animation: pulse 1.5s infinite; }

  .streaming-indicator {
    display: none;
    align-items: center;
    gap: 4px;
    font-size: 11px;
    color: #ffb000;
  }

  .streaming-indicator.active { display: flex; }

  .streaming-indicator .dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: #ffb000;
    animation: pulse 1s infinite;
  }

  .logout-btn {
    background: none;
    border: 1px solid #1a1a1a;
    color: #555;
    font-family: 'JetBrains Mono', ui-monospace, monospace;
    font-size: 11px;
    padding: 2px 8px;
    border-radius: 4px;
    cursor: pointer;
    transition: border-color 0.3s, color 0.3s;
  }
  .logout-btn:hover { border-color: #333; color: #888; }

  /* Messages area */
  #messages {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    background: #000;
  }

  #messages::-webkit-scrollbar { width: 6px; }
  #messages::-webkit-scrollbar-track { background: transparent; }
  #messages::-webkit-scrollbar-thumb { background: #1a1a1a; border-radius: 3px; }

  .msg { max-width: 100%; }

  .msg-system {
    color: #555;
    font-style: italic;
    font-size: 12px;
    text-align: center;
    padding: 4px 0;
  }

  .msg-user {
    align-self: flex-end;
    background: #0a0a0a;
    padding: 8px 12px;
    border-radius: 4px;
    border: 1px solid #1a1a1a;
    max-width: 80%;
    white-space: pre-wrap;
    word-break: break-word;
    color: #e0e0e0;
  }

  .msg-assistant {
    align-self: flex-start;
    max-width: 90%;
    white-space: pre-wrap;
    word-break: break-word;
    color: #b0b0b0;
  }

  .msg-assistant strong { color: #fff; }

  .msg-assistant code:not(pre code) {
    background: #111;
    padding: 1px 5px;
    border-radius: 3px;
    font-size: 12px;
    color: #e0e0e0;
  }

  .msg-assistant pre {
    background: #0a0a0a;
    border: 1px solid #1a1a1a;
    border-radius: 4px;
    padding: 10px;
    overflow-x: auto;
    margin: 6px 0;
    font-size: 12px;
    line-height: 1.4;
  }

  .msg-assistant pre code {
    background: none;
    padding: 0;
    color: #b0b0b0;
  }

  .msg-assistant a {
    color: #ffb000;
    text-decoration: underline;
    cursor: pointer;
  }

  .msg-thinking {
    color: #555;
    font-style: italic;
    font-size: 12px;
    border-left: 2px solid #1a1a1a;
    padding-left: 8px;
    margin: 4px 0;
    max-width: 90%;
    white-space: pre-wrap;
    word-break: break-word;
    transition: border-color 0.3s;
  }
  .msg-thinking:hover {
    border-color: #00ff41;
    background: rgba(0, 255, 65, 0.03);
  }

  .tool-call {
    margin: 4px 0;
    border: 1px solid #1a1a1a;
    border-radius: 4px;
    background: #0a0a0a;
    max-width: 90%;
  }

  .tool-call summary {
    padding: 6px 10px;
    font-size: 12px;
    color: #555;
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
    gap: 6px;
    border-left: 2px solid #1a1a1a;
    transition: border-color 0.3s, background 0.3s;
  }

  .tool-call summary:hover {
    color: #b0b0b0;
    border-color: #00ff41;
    background: rgba(0, 255, 65, 0.03);
  }

  .tool-call summary .tool-name {
    color: #ffb000;
    font-weight: 600;
  }

  .tool-call summary .tool-args {
    color: #555;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    flex: 1;
  }

  .tool-call .tool-result {
    padding: 8px 10px;
    border-top: 1px solid #1a1a1a;
    font-size: 12px;
    max-height: 300px;
    overflow: auto;
    white-space: pre-wrap;
    word-break: break-all;
    color: #555;
  }

  .tool-call .tool-result.error { color: #ef4444; }

  .error-card {
    background: #1a0a0a;
    border: 1px solid rgba(239, 68, 68, 0.3);
    border-radius: 4px;
    padding: 10px 12px;
    margin: 4px 0;
    max-width: 90%;
  }

  .error-card .error-title {
    color: #ef4444;
    font-weight: 600;
    font-size: 12px;
    margin-bottom: 4px;
  }

  .error-card pre {
    font-size: 11px;
    color: #555;
    white-space: pre-wrap;
    word-break: break-all;
  }

  /* Spark event card */
  @keyframes spark-event-flash {
    0% { border-color: rgba(239, 68, 68, 0.8); box-shadow: 0 0 20px rgba(239, 68, 68, 0.3), inset 0 0 20px rgba(239, 68, 68, 0.05); }
    100% { border-color: rgba(239, 68, 68, 0.3); box-shadow: none; }
  }

  .spark-event-card {
    background: linear-gradient(135deg, #1a0505 0%, #0d0000 100%);
    border: 1px solid rgba(239, 68, 68, 0.3);
    border-left: 3px solid #ef4444;
    border-radius: 6px;
    padding: 0;
    margin: 8px 0;
    max-width: 95%;
    overflow: hidden;
    animation: spark-event-flash 2s ease-out forwards;
  }

  .spark-event-card .spark-event-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 14px;
    border-bottom: 1px solid rgba(239, 68, 68, 0.15);
    background: rgba(239, 68, 68, 0.06);
  }

  .spark-event-card .spark-event-badge {
    font-size: 10px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 2px 8px;
    border-radius: 3px;
    background: rgba(239, 68, 68, 0.15);
    color: #ef4444;
    border: 1px solid rgba(239, 68, 68, 0.3);
    white-space: nowrap;
  }

  .spark-event-card .spark-event-route {
    color: #888;
    font-size: 12px;
  }

  .spark-event-card .spark-event-route .method {
    color: #ef4444;
    font-weight: 600;
  }

  .spark-event-card .spark-event-timestamp {
    margin-left: auto;
    color: #444;
    font-size: 10px;
    white-space: nowrap;
  }

  .spark-event-card .spark-event-body {
    padding: 12px 14px;
  }

  .spark-event-card .spark-event-error-msg {
    color: #ef4444;
    font-size: 12px;
    font-weight: 500;
    margin-bottom: 8px;
    line-height: 1.4;
  }

  .spark-event-card .spark-event-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin-bottom: 10px;
  }

  .spark-event-card .spark-event-meta-item {
    font-size: 11px;
  }

  .spark-event-card .spark-event-meta-item .label {
    color: #444;
    margin-right: 4px;
  }

  .spark-event-card .spark-event-meta-item .value {
    color: #888;
  }

  .spark-event-card .spark-event-stack {
    background: #0a0a0a;
    border: 1px solid #1a1a1a;
    border-radius: 4px;
    padding: 8px 10px;
    font-size: 11px;
    color: #555;
    line-height: 1.5;
    white-space: pre-wrap;
    word-break: break-all;
    max-height: 140px;
    overflow-y: auto;
  }

  .spark-event-card .spark-event-json-toggle {
    display: block;
    width: 100%;
    text-align: left;
    background: none;
    border: none;
    border-top: 1px solid rgba(239, 68, 68, 0.1);
    color: #333;
    font-family: 'JetBrains Mono', ui-monospace, monospace;
    font-size: 10px;
    padding: 6px 14px;
    cursor: pointer;
    transition: color 0.2s, background 0.2s;
  }

  .spark-event-card .spark-event-json-toggle:hover {
    color: #666;
    background: rgba(239, 68, 68, 0.03);
  }

  .spark-event-card .spark-event-json {
    display: none;
    padding: 10px 14px;
    border-top: 1px solid rgba(239, 68, 68, 0.1);
  }

  .spark-event-card .spark-event-json pre {
    background: #0a0a0a;
    border: 1px solid #1a1a1a;
    border-radius: 4px;
    padding: 10px;
    font-size: 11px;
    color: #666;
    line-height: 1.4;
    white-space: pre-wrap;
    word-break: break-all;
    max-height: 200px;
    overflow-y: auto;
  }

  .spark-event-card .spark-event-json pre .json-key { color: #ef4444; }
  .spark-event-card .spark-event-json pre .json-string { color: #888; }
  .spark-event-card .spark-event-json pre .json-number { color: #ffb000; }
  .spark-event-card .spark-event-json pre .json-bool { color: #22c55e; }
  .spark-event-card .spark-event-json pre .json-null { color: #555; }

  /* Input bar */
  #input-bar {
    display: flex;
    align-items: flex-end;
    gap: 10px;
    padding: 12px 16px;
    background: #000;
    border-top: 1px solid #1a1a1a;
    flex-shrink: 0;
  }

  #input-bar textarea {
    flex: 1;
    background: #0a0a0a;
    border: 1px solid #1a1a1a;
    border-radius: 4px;
    color: #e0e0e0;
    font-family: 'JetBrains Mono', ui-monospace, monospace;
    font-size: 13px;
    padding: 8px 10px;
    resize: none;
    outline: none;
    min-height: 36px;
    max-height: 144px;
    line-height: 1.4;
    transition: border-color 0.3s;
  }

  #input-bar textarea:focus { border-color: #00ff41; }
  #input-bar textarea::placeholder { color: #333; }

  #input-bar button {
    font-family: 'JetBrains Mono', ui-monospace, monospace;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    white-space: nowrap;
    flex-shrink: 0;
    transition: border-color 0.3s, color 0.3s;
  }

  #send-btn {
    background: transparent;
    color: #555;
    border: 1px solid #2a2a2a;
    border-radius: 4px;
    padding: 7px 16px;
    height: 36px;
  }

  #send-btn:hover:not(:disabled) {
    color: #00ff41;
    border-color: #00ff41;
  }

  #send-btn:disabled { opacity: 0.25; cursor: default; }

  #stop-btn {
    display: none;
    background: transparent;
    color: #ef4444;
    border: 1px solid rgba(239, 68, 68, 0.4);
    border-radius: 4px;
    padding: 7px 16px;
    height: 36px;
  }

  #stop-btn:hover {
    border-color: #ef4444;
    color: #ff6b6b;
  }

  /* Queued messages */
  #queued-messages:empty { display: none; }

  #queued-messages {
    flex-shrink: 0;
    padding: 0 16px;
    background: #000;
    border-top: 1px solid #1a1a1a;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .queued-msg {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    padding: 8px 12px;
    background: #0a0a0a;
    border: 1px solid #1a1a1a;
    border-radius: 4px;
    align-self: flex-end;
    max-width: 80%;
    animation: queued-fade-in 0.2s ease-out;
  }

  @keyframes queued-fade-in {
    from { opacity: 0; transform: translateY(4px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .queued-msg .queued-text {
    flex: 1;
    color: #888;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .queued-msg .queued-badge {
    flex-shrink: 0;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 2px 7px;
    border-radius: 3px;
    background: rgba(255, 176, 0, 0.08);
    color: #ffb000;
    border: 1px solid rgba(255, 176, 0, 0.2);
    white-space: nowrap;
    animation: queued-pulse 2s ease-in-out infinite;
  }

  @keyframes queued-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  #main-ui { display: flex; flex-direction: column; flex: 1; overflow: hidden; }
</style>
</head>
<body>

<div id="main-ui">
  <div id="header">
    <div class="logo">‚ö° <span class="spark-word">Spark</span></div>
    <span id="env-badge" class="badge badge-env"></span>
    <span id="mode-badge" class="badge badge-mode" style="display:none"></span>
    <div class="streaming-indicator" id="streaming-ind">
      <span class="dot"></span>
      <span>working</span>
    </div>
    <div class="spacer"></div>
    <div class="status-dot disconnected" id="status-dot" title="Disconnected"></div>
    <form method="POST" action="/logout" style="margin:0"><button type="submit" class="logout-btn">logout</button></form>
  </div>

  <div id="messages"></div>

  <div id="queued-messages"></div>

  <div id="input-bar">
    <textarea id="msg-input" rows="1" placeholder="Message Spark..." disabled></textarea>
    <button id="send-btn" disabled>Send</button>
    <button id="stop-btn">‚èπ Stop</button>
  </div>
</div>

<script>
(function() {
  let ws = null;
  let reconnectDelay = 2000;
  let reconnectTimer = null;
  let isStreaming = false;
  let isConnected = false;
  let sessionReady = false;
  let userScrolledUp = false;

  const mainUI = document.getElementById('main-ui');
  const messagesEl = document.getElementById('messages');
  const msgInput = document.getElementById('msg-input');
  const sendBtn = document.getElementById('send-btn');
  const stopBtn = document.getElementById('stop-btn');
  const statusDot = document.getElementById('status-dot');
  const envBadge = document.getElementById('env-badge');
  const modeBadge = document.getElementById('mode-badge');
  const streamingInd = document.getElementById('streaming-ind');
  let currentAssistantEl = null;
  let currentThinkingEl = null;
  let currentToolCalls = {};
  let streamingToolCall = null;

  // Track messages sent by this client.
  // Non-queued: rendered immediately in chat, echo suppressed.
  // Queued (sent while agent is streaming): shown in queued area, moved to chat on echo.
  let localSentMessages = [];  // { text, queued, el? }
  const queuedContainer = document.getElementById('queued-messages');

  connect();

  function connect() {
    if (ws) { try { ws.close(); } catch {} }
    setConnectionStatus('connecting');

    const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = proto + '//' + location.host + '/ws';
    ws = new WebSocket(wsUrl);

    ws.onopen = function() {
      isConnected = true;
      reconnectDelay = 2000;
      setConnectionStatus('connected');
      updateInputState();
    };

    ws.onmessage = function(e) {
      let data;
      try { data = JSON.parse(e.data); } catch { return; }
      handleEvent(data);
    };

    ws.onclose = function() {
      isConnected = false;
      sessionReady = false;
      localSentMessages = [];
      queuedContainer.innerHTML = '';
      setConnectionStatus('disconnected');
      updateInputState();
      clearTimeout(reconnectTimer);
      reconnectTimer = setTimeout(function() {
        reconnectDelay = Math.min(reconnectDelay * 2, 30000);
        connect();
      }, reconnectDelay);
    };

    ws.onerror = function() {};
  }

  function setConnectionStatus(status) {
    statusDot.className = 'status-dot ' + status;
    statusDot.title = status.charAt(0).toUpperCase() + status.slice(1);
  }

  function handleEvent(data) {
    switch (data.type) {
      case 'state':
        sessionReady = data.data.sessionReady;
        if (data.data.environment) {
          envBadge.textContent = data.data.environment === 'development' ? 'dev' : 'prod';
        }
        if (data.data.isStreaming) setStreaming(true);
        if (data.data.sessionError) appendSystem('Session error: ' + data.data.sessionError);
        updateInputState();
        break;
      case 'messages':
        messagesEl.innerHTML = '';
        renderHistory(data.messages || []);
        break;
      case 'message_start':
        if (data.message && data.message.role === 'assistant') {
          currentAssistantEl = null;
          currentThinkingEl = null;
          streamingToolCall = null;
        } else if (data.message && data.message.role === 'user') {
          var userText = typeof data.message.content === 'string' ? data.message.content : (Array.isArray(data.message.content) ? data.message.content.map(function(b) { return b.text || ''; }).join('') : '');
          if (userText.trim()) {
            // Check if this is an echo of a message we sent locally
            var idx = localSentMessages.findIndex(function(m) { return m.text === userText; });
            if (idx !== -1) {
              var entry = localSentMessages.splice(idx, 1)[0];
              if (entry.queued && entry.el) {
                // Was queued ‚Äî remove from queue area and render in chat
                entry.el.remove();
                appendUser(userText);
              }
              // Non-queued messages were already rendered ‚Äî just consume the echo
            } else {
              appendUserOrSparkEvent(userText);
            }
          }
        }
        break;
      case 'message_update':
        handleMessageUpdate(data.event);
        break;
      case 'message_end':
        currentAssistantEl = null;
        currentThinkingEl = null;
        streamingToolCall = null;
        break;
      case 'tool_start':
        handleToolStart(data);
        break;
      case 'tool_update':
        handleToolUpdate(data);
        break;
      case 'tool_end':
        handleToolEnd(data);
        break;
      case 'agent_start':
        setStreaming(true);
        break;
      case 'agent_end':
        setStreaming(false);
        break;
      case 'error':
        appendError('Error', data.message);
        break;
    }
  }

  function handleMessageUpdate(event) {
    if (!event) return;
    if (event.type === 'text_delta') {
      if (!currentAssistantEl) {
        currentAssistantEl = document.createElement('div');
        currentAssistantEl.className = 'msg msg-assistant';
        currentAssistantEl._rawText = '';
        messagesEl.appendChild(currentAssistantEl);
      }
      currentAssistantEl._rawText += event.delta;
      currentAssistantEl.innerHTML = renderMarkdown(currentAssistantEl._rawText);
      autoScroll();
    } else if (event.type === 'thinking_delta') {
      if (!currentThinkingEl) {
        currentThinkingEl = document.createElement('div');
        currentThinkingEl.className = 'msg msg-thinking';
        currentThinkingEl._rawText = '';
        messagesEl.appendChild(currentThinkingEl);
      }
      currentThinkingEl._rawText += event.delta;
      currentThinkingEl.textContent = currentThinkingEl._rawText;
      autoScroll();
    } else if (event.type === 'toolcall_start') {
      streamingToolCall = { id: event.toolCallId || '', name: event.toolName || '', argsBuffer: '' };
    } else if (event.type === 'toolcall_delta') {
      if (streamingToolCall) streamingToolCall.argsBuffer += (event.delta || '');
    } else if (event.type === 'toolcall_end') {
      if (streamingToolCall) {
        createToolCallEl(streamingToolCall.id || event.toolCallId, streamingToolCall.name || event.toolName, streamingToolCall.argsBuffer);
        streamingToolCall = null;
      }
    }
  }

  function handleToolStart(data) {
    const id = data.toolCallId;
    if (!currentToolCalls[id]) {
      createToolCallEl(id, data.toolName, typeof data.args === 'string' ? data.args : JSON.stringify(data.args, null, 2));
    }
  }

  function createToolCallEl(id, name, argsStr) {
    const details = document.createElement('details');
    details.className = 'tool-call';
    let argsPreview = '';
    try {
      const parsed = JSON.parse(argsStr);
      for (const k in parsed) {
        const v = parsed[k];
        if (typeof v === 'string') { argsPreview = v.length > 80 ? v.slice(0, 80) + '‚Ä¶' : v; break; }
      }
    } catch { argsPreview = argsStr ? (argsStr.length > 80 ? argsStr.slice(0, 80) + '‚Ä¶' : argsStr) : ''; }
    const summary = document.createElement('summary');
    summary.innerHTML = '<span class="tool-name">' + escapeHtml(name || '?') + '</span> <span class="tool-args">' + escapeHtml(argsPreview) + '</span>';
    const resultDiv = document.createElement('div');
    resultDiv.className = 'tool-result';
    resultDiv.textContent = 'Running...';
    details.appendChild(summary);
    details.appendChild(resultDiv);
    messagesEl.appendChild(details);
    if (id) currentToolCalls[id] = { el: details, resultEl: resultDiv, name: name };
    autoScroll();
  }

  function handleToolUpdate(data) {
    const tc = currentToolCalls[data.toolCallId];
    if (tc && data.partialResult != null) { tc.resultEl.textContent = String(data.partialResult); autoScroll(); }
  }

  function handleToolEnd(data) {
    const tc = currentToolCalls[data.toolCallId];
    if (tc) {
      let text = '';
      if (data.result != null) {
        if (typeof data.result === 'string') text = data.result;
        else if (Array.isArray(data.result)) text = data.result.map(function(b) { return b.text || ''; }).join('\n');
        else text = JSON.stringify(data.result, null, 2);
      }
      if (text.length > 5000) text = text.slice(0, 5000) + '\n‚Ä¶ (truncated)';
      tc.resultEl.textContent = text || '(no output)';
      if (data.isError) tc.resultEl.classList.add('error');
      delete currentToolCalls[data.toolCallId];
      autoScroll();
    }
  }

  function renderHistory(messages) {
    const toolResults = {};
    messages.forEach(function(m) { if (m.role === 'toolResult' && m.toolCallId) toolResults[m.toolCallId] = m; });
    messages.forEach(function(m) {
      if (m.role === 'user') {
        const text = typeof m.content === 'string' ? m.content : (Array.isArray(m.content) ? m.content.map(function(b) { return b.text || ''; }).join('') : '');
        if (text.trim()) appendUserOrSparkEvent(text);
      } else if (m.role === 'assistant' && Array.isArray(m.content)) {
        m.content.forEach(function(block) {
          if (block.type === 'text' && block.text) {
            const el = document.createElement('div');
            el.className = 'msg msg-assistant';
            el.innerHTML = renderMarkdown(block.text);
            messagesEl.appendChild(el);
          } else if (block.type === 'thinking' && block.thinking) {
            const el = document.createElement('div');
            el.className = 'msg msg-thinking';
            el.textContent = block.thinking;
            messagesEl.appendChild(el);
          } else if (block.type === 'toolCall') {
            const argsStr = typeof block.arguments === 'string' ? block.arguments : JSON.stringify(block.arguments, null, 2);
            createToolCallEl(block.id, block.name, argsStr);
            const tr = toolResults[block.id];
            if (tr) {
              const tc = currentToolCalls[block.id];
              if (tc) {
                let text = '';
                if (Array.isArray(tr.content)) text = tr.content.map(function(b) { return b.text || ''; }).join('\n');
                if (text.length > 5000) text = text.slice(0, 5000) + '\n‚Ä¶ (truncated)';
                tc.resultEl.textContent = text || '(no output)';
                if (tr.isError) tc.resultEl.classList.add('error');
                delete currentToolCalls[block.id];
              }
            }
          }
        });
      }
    });
    autoScroll();
  }

  function appendUser(text) {
    const el = document.createElement('div');
    el.className = 'msg msg-user';
    el.textContent = text;
    messagesEl.appendChild(el);
    autoScroll();
  }

  function appendUserOrSparkEvent(text) {
    // Check if this is a Spark event message (contains embedded event JSON)
    var jsonMatch = text.match(/```spark-events\n([\s\S]*?)\n```/);
    if (jsonMatch && text.indexOf('üî•') !== -1) {
      try {
        var events = JSON.parse(jsonMatch[1]);
        for (var i = 0; i < events.length; i++) {
          appendSparkEventCard(events[i]);
        }
        autoScroll();
        return;
      } catch (e) {}
    }
    // Fall back to regular user message
    appendUser(text);
  }

  function syntaxHighlightJson(json) {
    var str = JSON.stringify(json, null, 2);
    return escapeHtml(str).replace(/"([^"]+)"(\s*:)/g, '<span class="json-key">"$1"</span>$2').replace(/:\s*"([^"]*?)"/g, ': <span class="json-string">"$1"</span>').replace(/:\s*(\d+\.?\d*)/g, ': <span class="json-number">$1</span>').replace(/:\s*(true|false)/g, ': <span class="json-bool">$1</span>').replace(/:\s*null/g, ': <span class="json-null">null</span>');
  }

  function appendSparkEventCard(event) {
    var el = document.createElement('div');
    el.className = 'spark-event-card';

    var typeLabel = (event.type || 'unknown').replace(/-/g, ' ');
    var method = '';
    var path = '';
    if (event.route) {
      var parts = event.route.split(' ');
      method = parts[0] || '';
      path = parts.slice(1).join(' ') || '';
    }

    var ts = '';
    if (event.timestamp) {
      try {
        var d = new Date(event.timestamp);
        ts = d.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
      } catch (e) {}
    }

    var id = 'spark-json-' + Math.random().toString(36).slice(2, 10);

    var html = '<div class="spark-event-header">';
    html += '<span class="spark-event-badge">' + escapeHtml(typeLabel) + '</span>';
    if (event.feature) html += '<span class="spark-event-route"><code>' + escapeHtml(event.feature) + '</code></span>';
    if (method) html += '<span class="spark-event-route"><span class="method">' + escapeHtml(method) + '</span> ' + escapeHtml(path) + '</span>';
    if (event.status) html += '<span class="spark-event-badge" style="background:rgba(239,68,68,0.25)">' + event.status + '</span>';
    if (ts) html += '<span class="spark-event-timestamp">' + ts + '</span>';
    html += '</div>';

    html += '<div class="spark-event-body">';
    if (event.error && event.error.message) {
      html += '<div class="spark-event-error-msg">' + escapeHtml(event.error.message) + '</div>';
    }

    html += '<div class="spark-event-meta">';
    if (event.traceId) html += '<span class="spark-event-meta-item"><span class="label">trace</span><span class="value">' + escapeHtml(event.traceId) + '</span></span>';
    if (event.environment) html += '<span class="spark-event-meta-item"><span class="label">env</span><span class="value">' + escapeHtml(event.environment) + '</span></span>';
    html += '</div>';

    if (event.error && event.error.stack) {
      var stackLines = event.error.stack.split('\\n').slice(0, 6).join('\n');
      html += '<div class="spark-event-stack">' + escapeHtml(stackLines) + '</div>';
    }
    html += '</div>';

    html += '<button class="spark-event-json-toggle" onclick="var j=document.getElementById(\'' + id + '\');j.style.display=j.style.display===\'block\'?\'none\':\'block\';this.textContent=j.style.display===\'block\'?\'‚ñæ hide raw event\':\'‚ñ∏ show raw event\'">‚ñ∏ show raw event</button>';
    html += '<div class="spark-event-json" id="' + id + '"><pre>' + syntaxHighlightJson(event) + '</pre></div>';

    el.innerHTML = html;
    messagesEl.appendChild(el);
    autoScroll();
  }

  function createQueuedMessageEl(text) {
    var el = document.createElement('div');
    el.className = 'queued-msg';
    var textSpan = document.createElement('span');
    textSpan.className = 'queued-text';
    textSpan.textContent = text;
    var badge = document.createElement('span');
    badge.className = 'queued-badge';
    badge.textContent = 'queued';
    el.appendChild(textSpan);
    el.appendChild(badge);
    return el;
  }

  function appendSystem(text) {
    const el = document.createElement('div');
    el.className = 'msg msg-system';
    el.textContent = text;
    messagesEl.appendChild(el);
    autoScroll();
  }

  function appendError(title, message) {
    const el = document.createElement('div');
    el.className = 'error-card';
    el.innerHTML = '<div class="error-title">' + escapeHtml(title) + '</div><pre>' + escapeHtml(message || '') + '</pre>';
    messagesEl.appendChild(el);
    autoScroll();
  }

  function setStreaming(val) {
    isStreaming = val;
    streamingInd.classList.toggle('active', val);
    stopBtn.style.display = val ? 'inline-block' : 'none';
    updateInputState();
  }

  function updateInputState() {
    const enabled = isConnected && sessionReady;
    msgInput.disabled = !enabled;
    sendBtn.disabled = !enabled;
    msgInput.placeholder = !isConnected ? 'Disconnected...' : !sessionReady ? 'Session loading...' : 'Message Spark...';
  }

  messagesEl.addEventListener('scroll', function() {
    userScrolledUp = (messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight) > 50;
  });

  function autoScroll() {
    if (!userScrolledUp) messagesEl.scrollTop = messagesEl.scrollHeight;
  }

  msgInput.addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = Math.min(this.scrollHeight, 144) + 'px';
  });

  msgInput.addEventListener('keydown', function(e) {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
  });

  sendBtn.addEventListener('click', sendMessage);

  stopBtn.addEventListener('click', function() {
    if (ws && ws.readyState === 1) ws.send(JSON.stringify({ type: 'abort' }));
  });

  function sendMessage() {
    const text = msgInput.value.trim();
    if (!text || !ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify({ type: 'prompt', message: text }));

    if (isStreaming) {
      // Agent is busy ‚Äî this will be queued via session.followUp().
      // Show in the queued area instead of the main chat.
      var entry = { text: text, queued: true, el: null };
      entry.el = createQueuedMessageEl(text);
      queuedContainer.appendChild(entry.el);
      localSentMessages.push(entry);
    } else {
      // Agent is free ‚Äî render immediately in the chat.
      appendUser(text);
      localSentMessages.push({ text: text, queued: false });
    }

    msgInput.value = '';
    msgInput.style.height = 'auto';
  }

  function renderMarkdown(text) {
    let html = escapeHtml(text);
    html = html.replace(/```(\w*)\n([\s\S]*?)```/g, function(_, lang, code) { return '<pre><code>' + code + '</code></pre>'; });
    html = html.replace(/`([^`\n]+)`/g, '<code>$1</code>');
    html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, function(match, text, url) {
      if (/^(javascript|data|vbscript):/i.test(url)) return match;
      return '<a href="' + url + '" target="_blank" rel="noopener">' + text + '</a>';
    });
    return html;
  }

  function escapeHtml(str) {
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  }
})();
</script>
</body>
</html>
