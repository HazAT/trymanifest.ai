# Manifest Framework Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build the Manifest framework as a self-contained TypeScript/Bun starter project. The framework ships as source code - no hidden npm dependency. From zero to a working app where you define a feature file, run `bun manifest serve`, and hit the endpoint.

**Architecture:** A single project where the framework source lives in `manifest/` and application code lives in `features/`, `schemas/`, `services/`, etc. The `manifest/` directory IS the framework. It's ~500-800 lines of readable TypeScript. An agent can read every line of framework code to understand how things work.

**Tech Stack:** Bun 1.x, TypeScript 5.x (strict), Drizzle ORM (PostgreSQL + SQLite for dev)

**Core principle:** This is the most hackable agentic framework possible. Everything is source code. Nothing is hidden. An agent reads existing files and examples to understand how to build more.

---

## Project Structure (what we're building)

```
manifest-app/
├── manifest/                  # THE FRAMEWORK. Source code. Readable. Hackable.
│   ├── server.ts              # createManifestServer() - Bun.serve() wrapper
│   ├── feature.ts             # defineFeature() - feature definition + types
│   ├── types.ts               # t.string(), t.integer() - input type builders
│   ├── validator.ts           # validateInput() - validates data against input schema
│   ├── router.ts              # createRouter() - matches HTTP requests to features
│   ├── envelope.ts            # ok(), fail(), toEnvelope() - response formatting
│   ├── scanner.ts             # scanFeatures() - reads features/ directory
│   ├── testing.ts             # createTestClient() - test helper
│   └── cli/
│       ├── index.ts           # CLI entry point
│       ├── serve.ts           # serve command
│       ├── check.ts           # check command
│       ├── indexManifest.ts   # index command (generates MANIFEST.md)
│       └── makeFeature.ts     # make:feature command
│
├── features/                  # Application features (one file each)
│   └── HelloWorld.ts          # Demo feature
│
├── schemas/                   # Drizzle ORM schemas
├── services/                  # Shared services
├── commands/                  # Custom CLI commands
├── config/
│   ├── manifest.ts            # App config
│   └── database.ts            # DB config
│
├── tests/
│   └── HelloWorld.test.ts     # Demo test
│
├── index.ts                   # Entry point
├── package.json
├── tsconfig.json
└── MANIFEST.md                # Generated by `bun manifest index`
```

---

## Task 1: Project Scaffolding

**Files:**
- Create: `package.json`
- Create: `tsconfig.json`
- Create: `.gitignore`
- Create: directory structure

**Step 1: Create package.json**

```json
{
  "name": "manifest-app",
  "version": "0.1.0",
  "description": "Production is our dev environment.",
  "type": "module",
  "scripts": {
    "dev": "bun --hot index.ts",
    "start": "bun index.ts",
    "test": "bun test",
    "manifest": "bun manifest/cli/index.ts"
  },
  "dependencies": {
    "drizzle-orm": "^0.38.0"
  },
  "devDependencies": {
    "@types/bun": "latest",
    "drizzle-kit": "^0.30.0"
  }
}
```

**Step 2: Create tsconfig.json**

```json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": ".",
    "types": ["bun-types"],
    "paths": {
      "manifest": ["./manifest/index.ts"],
      "manifest/*": ["./manifest/*"]
    }
  },
  "include": ["**/*.ts"],
  "exclude": ["node_modules", "dist"]
}
```

**Step 3: Create .gitignore**

```
node_modules/
dist/
.env
*.log
```

**Step 4: Create directory structure**

```bash
mkdir -p manifest/cli
mkdir -p features
mkdir -p schemas
mkdir -p services
mkdir -p commands
mkdir -p config
mkdir -p tests
```

**Step 5: Run bun install**

```bash
bun install
```

**Step 6: Verify bun runs**

```bash
echo 'console.log("Manifest is alive")' > index.ts
bun index.ts
```

Expected: "Manifest is alive"

**Step 7: Commit**

```bash
git add -A
git commit -m "feat: project scaffolding with Bun and Drizzle ORM"
```

---

## Task 2: Input Type Builders (`manifest/types.ts`)

The `t` object provides type-safe builders for describing input fields. Each builder returns a plain object with type info, description, and constraints. This is used by `defineFeature()` to declare what inputs a feature accepts, and by `validateInput()` to validate incoming data.

**Files:**
- Create: `manifest/types.ts`
- Create: `tests/manifest/types.test.ts`

**Step 1: Write the failing test**

```typescript
// tests/manifest/types.test.ts
import { describe, test, expect } from 'bun:test'
import { t } from '../../manifest/types'

describe('t.string()', () => {
  test('creates a string field definition', () => {
    const field = t.string({
      description: 'User email address.',
      required: true,
      format: 'email',
    })

    expect(field.type).toBe('string')
    expect(field.description).toBe('User email address.')
    expect(field.required).toBe(true)
    expect(field.format).toBe('email')
  })

  test('defaults to not required', () => {
    const field = t.string({ description: 'Optional field.' })

    expect(field.required).toBe(false)
  })

  test('supports minLength and maxLength', () => {
    const field = t.string({
      description: 'Password.',
      required: true,
      minLength: 8,
      maxLength: 128,
    })

    expect(field.minLength).toBe(8)
    expect(field.maxLength).toBe(128)
  })
})

describe('t.integer()', () => {
  test('creates an integer field definition', () => {
    const field = t.integer({
      description: 'User age.',
      required: true,
      min: 0,
      max: 150,
    })

    expect(field.type).toBe('integer')
    expect(field.min).toBe(0)
    expect(field.max).toBe(150)
  })
})

describe('t.boolean()', () => {
  test('creates a boolean field definition', () => {
    const field = t.boolean({
      description: 'Accept terms.',
      required: true,
    })

    expect(field.type).toBe('boolean')
    expect(field.required).toBe(true)
  })
})

describe('t.array()', () => {
  test('creates an array field definition', () => {
    const field = t.array({
      description: 'Tags list.',
      itemType: 'string',
    })

    expect(field.type).toBe('array')
    expect(field.itemType).toBe('string')
  })
})

describe('t.number()', () => {
  test('creates a number field definition', () => {
    const field = t.number({
      description: 'Price in cents.',
      required: true,
      min: 0,
    })

    expect(field.type).toBe('number')
    expect(field.min).toBe(0)
  })
})
```

**Step 2: Run test to verify it fails**

```bash
bun test tests/manifest/types.test.ts
```

Expected: FAIL - module not found.

**Step 3: Write the implementation**

```typescript
// manifest/types.ts

/**
 * Input field definition. Describes a single input parameter for a feature.
 * Used by defineFeature() to declare inputs and by validateInput() to validate data.
 *
 * An agent reads these definitions to understand what a feature expects.
 * Every field MUST have a description explaining what it's for.
 */

export type FieldType = 'string' | 'integer' | 'number' | 'boolean' | 'array'

export interface BaseFieldDef {
  type: FieldType
  description: string
  required: boolean
}

export interface StringFieldDef extends BaseFieldDef {
  type: 'string'
  minLength?: number
  maxLength?: number
  format?: 'email' | 'url' | 'uuid' | 'date' | 'datetime'
  pattern?: string
}

export interface IntegerFieldDef extends BaseFieldDef {
  type: 'integer'
  min?: number
  max?: number
}

export interface NumberFieldDef extends BaseFieldDef {
  type: 'number'
  min?: number
  max?: number
}

export interface BooleanFieldDef extends BaseFieldDef {
  type: 'boolean'
}

export interface ArrayFieldDef extends BaseFieldDef {
  type: 'array'
  itemType: string
  minItems?: number
  maxItems?: number
}

export type FieldDef = StringFieldDef | IntegerFieldDef | NumberFieldDef | BooleanFieldDef | ArrayFieldDef

/**
 * Input schema is a plain object mapping field names to field definitions.
 */
export type InputSchemaDef = Record<string, FieldDef>

/**
 * Type builders for input field definitions.
 *
 * Usage:
 *   input: {
 *     email: t.string({ description: 'User email.', required: true, format: 'email' }),
 *     age: t.integer({ description: 'User age.', min: 0 }),
 *   }
 */
export const t = {
  string(opts: {
    description: string
    required?: boolean
    minLength?: number
    maxLength?: number
    format?: 'email' | 'url' | 'uuid' | 'date' | 'datetime'
    pattern?: string
  }): StringFieldDef {
    return {
      type: 'string',
      description: opts.description,
      required: opts.required ?? false,
      ...(opts.minLength !== undefined && { minLength: opts.minLength }),
      ...(opts.maxLength !== undefined && { maxLength: opts.maxLength }),
      ...(opts.format !== undefined && { format: opts.format }),
      ...(opts.pattern !== undefined && { pattern: opts.pattern }),
    }
  },

  integer(opts: {
    description: string
    required?: boolean
    min?: number
    max?: number
  }): IntegerFieldDef {
    return {
      type: 'integer',
      description: opts.description,
      required: opts.required ?? false,
      ...(opts.min !== undefined && { min: opts.min }),
      ...(opts.max !== undefined && { max: opts.max }),
    }
  },

  number(opts: {
    description: string
    required?: boolean
    min?: number
    max?: number
  }): NumberFieldDef {
    return {
      type: 'number',
      description: opts.description,
      required: opts.required ?? false,
      ...(opts.min !== undefined && { min: opts.min }),
      ...(opts.max !== undefined && { max: opts.max }),
    }
  },

  boolean(opts: {
    description: string
    required?: boolean
  }): BooleanFieldDef {
    return {
      type: 'boolean',
      description: opts.description,
      required: opts.required ?? false,
    }
  },

  array(opts: {
    description: string
    required?: boolean
    itemType: string
    minItems?: number
    maxItems?: number
  }): ArrayFieldDef {
    return {
      type: 'array',
      description: opts.description,
      required: opts.required ?? false,
      itemType: opts.itemType,
      ...(opts.minItems !== undefined && { minItems: opts.minItems }),
      ...(opts.maxItems !== undefined && { maxItems: opts.maxItems }),
    }
  },
}
```

**Step 4: Run test to verify it passes**

```bash
bun test tests/manifest/types.test.ts
```

Expected: 5 tests, all PASS.

**Step 5: Commit**

```bash
git add manifest/types.ts tests/manifest/types.test.ts
git commit -m "feat: input type builders (t.string, t.integer, t.number, t.boolean, t.array)"
```

---

## Task 3: Input Validator (`manifest/validator.ts`)

Validates incoming data against an input schema. Returns a plain object of errors (field name → error type) or an empty object if valid.

**Files:**
- Create: `manifest/validator.ts`
- Create: `tests/manifest/validator.test.ts`

**Step 1: Write the failing test**

```typescript
// tests/manifest/validator.test.ts
import { describe, test, expect } from 'bun:test'
import { validateInput } from '../../manifest/validator'
import { t } from '../../manifest/types'

const schema = {
  email: t.string({ description: 'Email.', required: true, format: 'email' }),
  password: t.string({ description: 'Password.', required: true, minLength: 8, maxLength: 128 }),
  displayName: t.string({ description: 'Name.', required: true, maxLength: 50 }),
  bio: t.string({ description: 'Bio.', required: false, maxLength: 500 }),
  age: t.integer({ description: 'Age.', required: false, min: 0, max: 150 }),
  score: t.number({ description: 'Score.', required: false, min: 0 }),
  acceptTerms: t.boolean({ description: 'Terms.', required: true }),
  tags: t.array({ description: 'Tags.', itemType: 'string', required: false }),
}

describe('validateInput', () => {
  test('passes with valid input', () => {
    const errors = validateInput(schema, {
      email: 'user@example.com',
      password: 'secure-pass-123',
      displayName: 'Jane',
      acceptTerms: true,
    })

    expect(errors).toEqual({})
  })

  test('catches missing required fields', () => {
    const errors = validateInput(schema, {})

    expect(errors.email).toBe('required')
    expect(errors.password).toBe('required')
    expect(errors.displayName).toBe('required')
    expect(errors.acceptTerms).toBe('required')
    expect(errors.bio).toBeUndefined()
    expect(errors.age).toBeUndefined()
  })

  test('catches invalid email format', () => {
    const errors = validateInput(schema, {
      email: 'not-an-email',
      password: 'secure-pass-123',
      displayName: 'Jane',
      acceptTerms: true,
    })

    expect(errors.email).toBe('invalid_format')
  })

  test('catches string too short', () => {
    const errors = validateInput(schema, {
      email: 'user@example.com',
      password: 'short',
      displayName: 'Jane',
      acceptTerms: true,
    })

    expect(errors.password).toBe('min_length')
  })

  test('catches string too long', () => {
    const errors = validateInput(schema, {
      email: 'user@example.com',
      password: 'secure-pass-123',
      displayName: 'A'.repeat(51),
      acceptTerms: true,
    })

    expect(errors.displayName).toBe('max_length')
  })

  test('catches integer out of range', () => {
    const errors = validateInput(schema, {
      email: 'user@example.com',
      password: 'secure-pass-123',
      displayName: 'Jane',
      acceptTerms: true,
      age: -1,
    })

    expect(errors.age).toBe('min')
  })

  test('catches number out of range', () => {
    const errors = validateInput(schema, {
      email: 'user@example.com',
      password: 'secure-pass-123',
      displayName: 'Jane',
      acceptTerms: true,
      score: -5,
    })

    expect(errors.score).toBe('min')
  })

  test('ignores optional fields when absent', () => {
    const errors = validateInput(schema, {
      email: 'user@example.com',
      password: 'secure-pass-123',
      displayName: 'Jane',
      acceptTerms: true,
    })

    expect(errors).toEqual({})
  })
})
```

**Step 2: Run test to verify it fails**

```bash
bun test tests/manifest/validator.test.ts
```

**Step 3: Write the implementation**

```typescript
// manifest/validator.ts

/**
 * Validates input data against an input schema.
 *
 * Returns a plain object of errors: { fieldName: 'error_type' }
 * Empty object means valid. This function is pure - no side effects.
 *
 * Error types:
 *   'required'       - Required field is missing or empty
 *   'invalid_format' - String doesn't match the declared format (email, url, etc.)
 *   'min_length'     - String is shorter than minLength
 *   'max_length'     - String is longer than maxLength
 *   'min'            - Number is less than min
 *   'max'            - Number is greater than max
 *   'invalid_type'   - Value is not the expected type
 */

import type { InputSchemaDef, FieldDef } from './types'

export function validateInput(
  schema: InputSchemaDef,
  data: Record<string, unknown>,
): Record<string, string> {
  const errors: Record<string, string> = {}

  for (const [name, field] of Object.entries(schema)) {
    const value = data[name]

    // Check required
    if (value === undefined || value === null || value === '') {
      if (field.required) {
        errors[name] = 'required'
      }
      continue
    }

    // Type-specific validation
    const error = validateField(field, value)
    if (error) {
      errors[name] = error
    }
  }

  return errors
}

function validateField(field: FieldDef, value: unknown): string | null {
  switch (field.type) {
    case 'string':
      return validateString(field, value)
    case 'integer':
      return validateInteger(field, value)
    case 'number':
      return validateNumber(field, value)
    case 'boolean':
      return validateBoolean(value)
    case 'array':
      return validateArray(field, value)
    default:
      return null
  }
}

function validateString(
  field: { format?: string; minLength?: number; maxLength?: number },
  value: unknown,
): string | null {
  if (typeof value !== 'string') return 'invalid_type'

  if (field.format === 'email') {
    // Simple email check: has @ and at least one dot after @
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    if (!emailRegex.test(value)) return 'invalid_format'
  }

  if (field.format === 'url') {
    try {
      new URL(value)
    } catch {
      return 'invalid_format'
    }
  }

  if (field.format === 'uuid') {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
    if (!uuidRegex.test(value)) return 'invalid_format'
  }

  if (field.minLength !== undefined && value.length < field.minLength) return 'min_length'
  if (field.maxLength !== undefined && value.length > field.maxLength) return 'max_length'

  return null
}

function validateInteger(
  field: { min?: number; max?: number },
  value: unknown,
): string | null {
  if (typeof value !== 'number' || !Number.isInteger(value)) return 'invalid_type'
  if (field.min !== undefined && value < field.min) return 'min'
  if (field.max !== undefined && value > field.max) return 'max'
  return null
}

function validateNumber(
  field: { min?: number; max?: number },
  value: unknown,
): string | null {
  if (typeof value !== 'number') return 'invalid_type'
  if (field.min !== undefined && value < field.min) return 'min'
  if (field.max !== undefined && value > field.max) return 'max'
  return null
}

function validateBoolean(value: unknown): string | null {
  if (typeof value !== 'boolean') return 'invalid_type'
  return null
}

function validateArray(
  field: { minItems?: number; maxItems?: number },
  value: unknown,
): string | null {
  if (!Array.isArray(value)) return 'invalid_type'
  if (field.minItems !== undefined && value.length < field.minItems) return 'min_items'
  if (field.maxItems !== undefined && value.length > field.maxItems) return 'max_items'
  return null
}
```

**Step 4: Run test to verify it passes**

```bash
bun test tests/manifest/validator.test.ts
```

Expected: 8 tests, all PASS.

**Step 5: Commit**

```bash
git add manifest/validator.ts tests/manifest/validator.test.ts
git commit -m "feat: input validator with format, length, and range checks"
```

---

## Task 4: Feature Definition (`manifest/feature.ts`)

The `defineFeature()` function and all related types. This is the core API that users interact with.

**Files:**
- Create: `manifest/feature.ts`
- Create: `tests/manifest/feature.test.ts`

**Step 1: Write the failing test**

```typescript
// tests/manifest/feature.test.ts
import { describe, test, expect } from 'bun:test'
import { defineFeature, type FeatureDef } from '../../manifest/feature'
import { t } from '../../manifest/types'

describe('defineFeature', () => {
  test('returns a typed feature definition', () => {
    const feature = defineFeature({
      name: 'hello-world',
      description: 'Says hello.',
      route: ['GET', '/api/hello'],
      authentication: 'none',
      sideEffects: [],
      errorCases: [],

      input: {
        name: t.string({ description: 'Who to greet.', required: false }),
      },

      async handle({ input, ok }) {
        const name = input.name ?? 'World'
        return ok(`Hello, ${name}!`, { data: { greeting: `Hello, ${name}!` } })
      },
    })

    expect(feature.name).toBe('hello-world')
    expect(feature.description).toBe('Says hello.')
    expect(feature.route).toEqual(['GET', '/api/hello'])
    expect(feature.type).toBe('request')
    expect(feature.authentication).toBe('none')
    expect(feature.input.name.type).toBe('string')
    expect(typeof feature.handle).toBe('function')
  })

  test('defaults type to request', () => {
    const feature = defineFeature({
      name: 'test',
      description: 'Test.',
      route: ['GET', '/test'],
      input: {},
      async handle({ ok }) { return ok('Done') },
    })

    expect(feature.type).toBe('request')
  })

  test('defaults authentication to required', () => {
    const feature = defineFeature({
      name: 'test',
      description: 'Test.',
      route: ['GET', '/test'],
      input: {},
      async handle({ ok }) { return ok('Done') },
    })

    expect(feature.authentication).toBe('required')
  })

  test('handle context provides ok and fail helpers', async () => {
    const feature = defineFeature({
      name: 'test',
      description: 'Test.',
      route: ['GET', '/test'],
      input: {},
      async handle({ ok }) {
        return ok('It works', { data: { value: 42 }, status: 201 })
      },
    })

    const result = await feature.handle({
      input: {},
      ok: (message, opts) => ({
        success: true,
        status: opts?.status ?? 200,
        message,
        data: opts?.data ?? null,
        errors: {},
      }),
      fail: (message, status) => ({
        success: false,
        status: status ?? 400,
        message,
        data: null,
        errors: {},
      }),
    })

    expect(result.success).toBe(true)
    expect(result.status).toBe(201)
    expect(result.message).toBe('It works')
    expect(result.data).toEqual({ value: 42 })
  })

  test('handle context provides fail helper', async () => {
    const feature = defineFeature({
      name: 'test',
      description: 'Test.',
      route: ['POST', '/test'],
      input: {},
      async handle({ fail }) {
        return fail('Something went wrong', 409)
      },
    })

    const result = await feature.handle({
      input: {},
      ok: (message, opts) => ({
        success: true,
        status: opts?.status ?? 200,
        message,
        data: opts?.data ?? null,
        errors: {},
      }),
      fail: (message, status) => ({
        success: false,
        status: status ?? 400,
        message,
        data: null,
        errors: {},
      }),
    })

    expect(result.success).toBe(false)
    expect(result.status).toBe(409)
  })
})
```

**Step 2: Run test to verify it fails**

```bash
bun test tests/manifest/feature.test.ts
```

**Step 3: Write the implementation**

```typescript
// manifest/feature.ts

/**
 * Feature definition and types.
 *
 * A feature is a self-contained unit of application behavior.
 * It's defined as a plain typed object using defineFeature().
 *
 * This file is the core API of the Manifest framework.
 * An agent reading this file understands how every feature in the app works.
 */

import type { InputSchemaDef } from './types'

/**
 * The result returned by a feature's handle() function.
 */
export interface FeatureResult {
  success: boolean
  status: number
  message: string
  data: unknown
  errors: Record<string, string>
}

/**
 * The context passed to a feature's handle() function.
 * Contains the validated input and helper functions for building results.
 */
export interface HandleContext<TInput = Record<string, unknown>> {
  /** Validated input data. Fields are typed based on the input schema. */
  input: TInput

  /** Return a success result. */
  ok: (message: string, opts?: { data?: unknown; status?: number }) => FeatureResult

  /** Return a failure result. */
  fail: (message: string, status?: number) => FeatureResult
}

/**
 * Feature definition object. This is what users pass to defineFeature().
 */
export interface FeatureOptions<TInput = Record<string, unknown>> {
  /** Unique feature identifier. Kebab-case. Used in tests, logs, MANIFEST.md. */
  name: string

  /** What this feature does. Written for agents - be verbose and specific. */
  description: string

  /** [METHOD, PATH] for HTTP features. Example: ['POST', '/api/users/register'] */
  route: [string, string] | []

  /** 'request' (default), 'stream' (SSE), or 'event' (triggered internally). */
  type?: 'request' | 'stream' | 'event'

  /** 'required' (default), 'none', or 'optional'. */
  authentication?: 'required' | 'none' | 'optional'

  /** Rate limit expression like '5/minute/ip'. Undefined means no limit. */
  rateLimit?: string

  /** Event name that triggers this feature. Only for type='event'. */
  trigger?: string

  /** Human/agent-readable list of side effects. Declared BEFORE reading the logic. */
  sideEffects?: string[]

  /** Human/agent-readable list of error cases with HTTP status codes. */
  errorCases?: string[]

  /** Input field definitions. Each field must have a description. */
  input: InputSchemaDef

  /** The feature's logic. Receives validated input and result helpers. */
  handle: (context: HandleContext<TInput>) => Promise<FeatureResult>
}

/**
 * The resolved feature definition with all defaults applied.
 */
export interface FeatureDef<TInput = Record<string, unknown>> extends Required<
  Pick<FeatureOptions<TInput>, 'name' | 'description' | 'route' | 'type' | 'authentication' | 'input' | 'handle'>
> {
  rateLimit: string | undefined
  trigger: string | undefined
  sideEffects: string[]
  errorCases: string[]
}

/**
 * Define a feature. This is the primary API of the Manifest framework.
 *
 * Usage:
 *   export default defineFeature({
 *     name: 'user-registration',
 *     description: 'Creates a new user account.',
 *     route: ['POST', '/api/users/register'],
 *     input: { email: t.string({ description: 'Email.', required: true }) },
 *     async handle({ input, ok, fail }) { ... },
 *   })
 */
export function defineFeature<TInput = Record<string, unknown>>(
  options: FeatureOptions<TInput>,
): FeatureDef<TInput> {
  return {
    name: options.name,
    description: options.description,
    route: options.route,
    type: options.type ?? 'request',
    authentication: options.authentication ?? 'required',
    rateLimit: options.rateLimit,
    trigger: options.trigger,
    sideEffects: options.sideEffects ?? [],
    errorCases: options.errorCases ?? [],
    input: options.input,
    handle: options.handle,
  }
}
```

**Step 4: Run test to verify it passes**

```bash
bun test tests/manifest/feature.test.ts
```

Expected: 5 tests, all PASS.

**Step 5: Commit**

```bash
git add manifest/feature.ts tests/manifest/feature.test.ts
git commit -m "feat: defineFeature() core API with typed feature definitions"
```

---

## Task 5: Response Envelope (`manifest/envelope.ts`)

Helper functions for building the standard response envelope. Used by the server to format all responses consistently.

**Files:**
- Create: `manifest/envelope.ts`
- Create: `tests/manifest/envelope.test.ts`

**Step 1: Write the failing test**

```typescript
// tests/manifest/envelope.test.ts
import { describe, test, expect } from 'bun:test'
import { toEnvelope, createResultHelpers } from '../../manifest/envelope'

describe('toEnvelope', () => {
  test('formats a success result', () => {
    const envelope = toEnvelope(
      {
        success: true,
        status: 201,
        message: 'User registered',
        data: { id: '123', email: 'user@example.com' },
        errors: {},
      },
      {
        featureName: 'user-registration',
        requestId: 'req_abc123',
        durationMs: 42,
      },
    )

    expect(envelope.status).toBe(201)
    expect(envelope.message).toBe('User registered')
    expect(envelope.data).toEqual({ id: '123', email: 'user@example.com' })
    expect(envelope.meta.feature).toBe('user-registration')
    expect(envelope.meta.request_id).toBe('req_abc123')
    expect(envelope.meta.duration_ms).toBe(42)
    expect(envelope.errors).toBeUndefined()
  })

  test('formats an error result', () => {
    const envelope = toEnvelope(
      {
        success: false,
        status: 422,
        message: 'Validation failed',
        data: null,
        errors: { email: 'required', password: 'required' },
      },
      {
        featureName: 'user-registration',
        requestId: 'req_abc123',
        durationMs: 5,
      },
    )

    expect(envelope.status).toBe(422)
    expect(envelope.errors).toEqual({ email: 'required', password: 'required' })
    expect(envelope.data).toBeUndefined()
  })
})

describe('createResultHelpers', () => {
  test('ok() creates a success result', () => {
    const { ok } = createResultHelpers()
    const result = ok('Done', { data: { id: 1 }, status: 201 })

    expect(result.success).toBe(true)
    expect(result.status).toBe(201)
    expect(result.message).toBe('Done')
    expect(result.data).toEqual({ id: 1 })
  })

  test('ok() defaults to status 200', () => {
    const { ok } = createResultHelpers()
    const result = ok('Done')

    expect(result.status).toBe(200)
  })

  test('fail() creates a failure result', () => {
    const { fail } = createResultHelpers()
    const result = fail('Not found', 404)

    expect(result.success).toBe(false)
    expect(result.status).toBe(404)
    expect(result.message).toBe('Not found')
  })

  test('fail() defaults to status 400', () => {
    const { fail } = createResultHelpers()
    const result = fail('Bad request')

    expect(result.status).toBe(400)
  })
})
```

**Step 2: Run test to verify it fails**

```bash
bun test tests/manifest/envelope.test.ts
```

**Step 3: Write the implementation**

```typescript
// manifest/envelope.ts

/**
 * Response envelope formatting.
 *
 * Every Manifest response follows the same envelope shape:
 * {
 *   status: number,
 *   message: string,
 *   data?: unknown,
 *   errors?: Record<string, string>,
 *   meta: { feature: string, request_id: string, duration_ms: number }
 * }
 *
 * This makes responses predictable for both frontend clients and agents.
 * An agent parsing error logs can always find meta.feature to know which
 * feature produced the response.
 */

import type { FeatureResult } from './feature'

export interface ResponseEnvelope {
  status: number
  message: string
  data?: unknown
  errors?: Record<string, string>
  meta: {
    feature: string
    request_id: string
    duration_ms: number
  }
}

export function toEnvelope(
  result: FeatureResult,
  meta: {
    featureName: string
    requestId: string
    durationMs: number
  },
): ResponseEnvelope {
  const envelope: ResponseEnvelope = {
    status: result.status,
    message: result.message,
    meta: {
      feature: meta.featureName,
      request_id: meta.requestId,
      duration_ms: meta.durationMs,
    },
  }

  if (result.success && result.data !== null) {
    envelope.data = result.data
  }

  if (!result.success && Object.keys(result.errors).length > 0) {
    envelope.errors = result.errors
  }

  return envelope
}

/**
 * Creates ok() and fail() helper functions for use in feature handle() contexts.
 */
export function createResultHelpers() {
  return {
    ok(message: string, opts?: { data?: unknown; status?: number }): FeatureResult {
      return {
        success: true,
        status: opts?.status ?? 200,
        message,
        data: opts?.data ?? null,
        errors: {},
      }
    },

    fail(message: string, status?: number): FeatureResult {
      return {
        success: false,
        status: status ?? 400,
        message,
        data: null,
        errors: {},
      }
    },
  }
}
```

**Step 4: Run test to verify it passes**

```bash
bun test tests/manifest/envelope.test.ts
```

Expected: 6 tests, all PASS.

**Step 5: Commit**

```bash
git add manifest/envelope.ts tests/manifest/envelope.test.ts
git commit -m "feat: response envelope formatting with ok() and fail() helpers"
```

---

## Task 6: Feature Scanner (`manifest/scanner.ts`)

Reads the `features/` directory, dynamically imports each `.ts` file, and returns a registry of all features.

**Files:**
- Create: `manifest/scanner.ts`
- Create: `tests/manifest/scanner.test.ts`
- Create: `features/HelloWorld.ts` (demo feature for testing)

**Step 1: Create the demo feature first (scanner tests depend on it)**

```typescript
// features/HelloWorld.ts
import { defineFeature, t } from '../manifest/feature'
import { t as types } from '../manifest/types'

export default defineFeature({
  name: 'hello-world',
  description: `A simple greeting endpoint. Returns a hello message with the
                provided name, or "World" if no name is given. This is the
                default demo feature that ships with every Manifest project.`,
  route: ['GET', '/api/hello'],
  authentication: 'none',
  sideEffects: [],
  errorCases: [],

  input: {
    name: types.string({
      description: 'The name to greet. Defaults to "World" if not provided.',
      required: false,
      maxLength: 100,
    }),
  },

  async handle({ input, ok }) {
    const name = (input as Record<string, unknown>).name ?? 'World'
    return ok(`Hello, ${name}!`, {
      data: { greeting: `Hello, ${name}!` },
    })
  },
})
```

Note: The import from `'../manifest/feature'` uses relative paths because the framework IS source code in the project. No npm package.

**Step 2: Write the failing test**

```typescript
// tests/manifest/scanner.test.ts
import { describe, test, expect } from 'bun:test'
import { scanFeatures, type FeatureRegistry } from '../../manifest/scanner'
import path from 'path'

describe('scanFeatures', () => {
  test('scans features directory and returns registry', async () => {
    const registry = await scanFeatures(path.resolve(__dirname, '../../features'))

    expect(Object.keys(registry).length).toBeGreaterThan(0)
    expect(registry['hello-world']).toBeDefined()
    expect(registry['hello-world'].name).toBe('hello-world')
    expect(registry['hello-world'].route).toEqual(['GET', '/api/hello'])
  })

  test('returns empty registry for empty directory', async () => {
    const tmpDir = path.join(import.meta.dir, '__empty_test_dir__')
    await Bun.write(path.join(tmpDir, '.gitkeep'), '')
    const registry = await scanFeatures(tmpDir)

    expect(Object.keys(registry)).toHaveLength(0)

    // Cleanup
    const fs = await import('fs')
    fs.rmSync(tmpDir, { recursive: true })
  })

  test('indexes features by name', async () => {
    const registry = await scanFeatures(path.resolve(__dirname, '../../features'))

    const feature = registry['hello-world']
    expect(feature).toBeDefined()
    expect(feature.description).toContain('greeting')
  })
})
```

**Step 3: Run test to verify it fails**

```bash
bun test tests/manifest/scanner.test.ts
```

**Step 4: Write the implementation**

```typescript
// manifest/scanner.ts

/**
 * Feature scanner. Reads a directory of .ts files, dynamically imports each one,
 * and builds a registry keyed by feature name.
 *
 * Each .ts file in the features directory should export a default feature
 * definition created with defineFeature(). The scanner imports the module
 * and reads the default export.
 *
 * This file is ~40 lines. An agent can read it in seconds to understand
 * how feature discovery works.
 */

import type { FeatureDef } from './feature'
import { readdirSync } from 'fs'
import path from 'path'

/**
 * A map of feature name → feature definition.
 */
export type FeatureRegistry = Record<string, FeatureDef>

/**
 * Scan a directory for .ts files that export feature definitions.
 * Returns a registry keyed by feature name.
 */
export async function scanFeatures(featuresDir: string): Promise<FeatureRegistry> {
  const registry: FeatureRegistry = {}

  let files: string[]
  try {
    files = readdirSync(featuresDir)
  } catch {
    return registry
  }

  const tsFiles = files.filter((f) => f.endsWith('.ts') && !f.endsWith('.test.ts'))

  for (const file of tsFiles) {
    const fullPath = path.resolve(featuresDir, file)
    try {
      const mod = await import(fullPath)
      const feature = mod.default as FeatureDef | undefined

      if (feature && typeof feature === 'object' && feature.name) {
        registry[feature.name] = feature
      }
    } catch (err) {
      console.error(`[manifest] Failed to load feature from ${file}:`, err)
    }
  }

  return registry
}
```

**Step 5: Run test to verify it passes**

```bash
bun test tests/manifest/scanner.test.ts
```

Expected: 3 tests, all PASS.

**Step 6: Commit**

```bash
git add manifest/scanner.ts tests/manifest/scanner.test.ts features/HelloWorld.ts
git commit -m "feat: feature scanner with dynamic import and registry"
```

---

## Task 7: Router (`manifest/router.ts`)

Matches HTTP requests to features by method and path. Supports path parameters (e.g., `/api/users/:id`).

**Files:**
- Create: `manifest/router.ts`
- Create: `tests/manifest/router.test.ts`

**Step 1: Write the failing test**

```typescript
// tests/manifest/router.test.ts
import { describe, test, expect } from 'bun:test'
import { createRouter } from '../../manifest/router'
import { defineFeature } from '../../manifest/feature'

const features = {
  'hello-world': defineFeature({
    name: 'hello-world',
    description: 'Says hello.',
    route: ['GET', '/api/hello'],
    input: {},
    async handle({ ok }) { return ok('Hello!') },
  }),
  'create-user': defineFeature({
    name: 'create-user',
    description: 'Creates user.',
    route: ['POST', '/api/users'],
    input: {},
    async handle({ ok }) { return ok('Created') },
  }),
  'get-user': defineFeature({
    name: 'get-user',
    description: 'Gets a user by ID.',
    route: ['GET', '/api/users/:id'],
    input: {},
    async handle({ ok }) { return ok('Got user') },
  }),
  'order-webhook': defineFeature({
    name: 'order-webhook',
    description: 'Internal event.',
    type: 'event',
    trigger: 'order.shipped',
    route: [],
    input: {},
    async handle({ ok }) { return ok('Sent') },
  }),
}

describe('createRouter', () => {
  const router = createRouter(features)

  test('matches exact routes', () => {
    const match = router.match('GET', '/api/hello')

    expect(match).not.toBeNull()
    expect(match!.feature.name).toBe('hello-world')
    expect(match!.params).toEqual({})
  })

  test('matches routes with correct method', () => {
    const match = router.match('POST', '/api/users')

    expect(match).not.toBeNull()
    expect(match!.feature.name).toBe('create-user')
  })

  test('returns null for wrong method', () => {
    const match = router.match('DELETE', '/api/hello')

    expect(match).toBeNull()
  })

  test('returns null for unknown path', () => {
    const match = router.match('GET', '/api/unknown')

    expect(match).toBeNull()
  })

  test('matches path parameters', () => {
    const match = router.match('GET', '/api/users/abc-123')

    expect(match).not.toBeNull()
    expect(match!.feature.name).toBe('get-user')
    expect(match!.params).toEqual({ id: 'abc-123' })
  })

  test('skips event-type features (no route)', () => {
    const match = router.match('GET', '/order-webhook')

    expect(match).toBeNull()
  })

  test('isMethodNotAllowed detects wrong method', () => {
    const result = router.isMethodNotAllowed('DELETE', '/api/hello')

    expect(result).toBe(true)
  })

  test('isMethodNotAllowed returns false for unknown paths', () => {
    const result = router.isMethodNotAllowed('GET', '/api/unknown')

    expect(result).toBe(false)
  })
})
```

**Step 2: Run test to verify it fails**

```bash
bun test tests/manifest/router.test.ts
```

**Step 3: Write the implementation**

```typescript
// manifest/router.ts

/**
 * HTTP router. Matches incoming requests to features by method and path.
 *
 * Supports:
 *   - Exact paths: /api/hello
 *   - Path parameters: /api/users/:id
 *
 * This router is intentionally simple (~60 lines). No regex-based matching,
 * no middleware chains, no wildcard routes. An agent can read this entire
 * file and understand exactly how routing works.
 */

import type { FeatureDef } from './feature'
import type { FeatureRegistry } from './scanner'

interface RouteEntry {
  method: string
  path: string
  segments: string[]
  paramNames: string[]
  feature: FeatureDef
}

export interface RouteMatch {
  feature: FeatureDef
  params: Record<string, string>
}

export interface Router {
  match(method: string, path: string): RouteMatch | null
  isMethodNotAllowed(method: string, path: string): boolean
}

export function createRouter(registry: FeatureRegistry): Router {
  const routes: RouteEntry[] = []

  for (const feature of Object.values(registry)) {
    if (feature.type === 'event' || feature.route.length === 0) continue

    const [method, routePath] = feature.route
    const segments = routePath.split('/').filter(Boolean)
    const paramNames = segments
      .filter((s) => s.startsWith(':'))
      .map((s) => s.slice(1))

    routes.push({ method, path: routePath, segments, paramNames, feature })
  }

  return {
    match(method: string, path: string): RouteMatch | null {
      const pathSegments = path.split('/').filter(Boolean)

      for (const route of routes) {
        if (route.method !== method) continue
        if (route.segments.length !== pathSegments.length) continue

        const params: Record<string, string> = {}
        let matched = true

        for (let i = 0; i < route.segments.length; i++) {
          const routeSeg = route.segments[i]
          const pathSeg = pathSegments[i]

          if (routeSeg.startsWith(':')) {
            params[routeSeg.slice(1)] = pathSeg
          } else if (routeSeg !== pathSeg) {
            matched = false
            break
          }
        }

        if (matched) {
          return { feature: route.feature, params }
        }
      }

      return null
    },

    isMethodNotAllowed(method: string, path: string): boolean {
      const pathSegments = path.split('/').filter(Boolean)

      for (const route of routes) {
        if (route.segments.length !== pathSegments.length) continue

        let pathMatches = true
        for (let i = 0; i < route.segments.length; i++) {
          const routeSeg = route.segments[i]
          const pathSeg = pathSegments[i]
          if (!routeSeg.startsWith(':') && routeSeg !== pathSeg) {
            pathMatches = false
            break
          }
        }

        if (pathMatches && route.method !== method) {
          return true
        }
      }

      return false
    },
  }
}
```

**Step 4: Run test to verify it passes**

```bash
bun test tests/manifest/router.test.ts
```

Expected: 8 tests, all PASS.

**Step 5: Commit**

```bash
git add manifest/router.ts tests/manifest/router.test.ts
git commit -m "feat: HTTP router with path parameter support"
```

---

## Task 8: Server (`manifest/server.ts`)

The main server. Ties together scanner, router, validator, and envelope into a Bun.serve() handler.

**Files:**
- Create: `manifest/server.ts`
- Create: `tests/manifest/server.test.ts`

**Step 1: Write the failing test**

```typescript
// tests/manifest/server.test.ts
import { describe, test, expect, beforeAll, afterAll } from 'bun:test'
import { createManifestServer } from '../../manifest/server'
import path from 'path'

describe('createManifestServer', () => {
  let server: Awaited<ReturnType<typeof createManifestServer>>
  let baseUrl: string

  beforeAll(async () => {
    server = await createManifestServer({
      projectDir: path.resolve(__dirname, '../..'),
      port: 0, // random available port
    })
    baseUrl = `http://localhost:${server.port}`
  })

  afterAll(() => {
    server.stop()
  })

  test('responds to a known feature route', async () => {
    const res = await fetch(`${baseUrl}/api/hello?name=Jane`)
    const body = await res.json()

    expect(res.status).toBe(200)
    expect(body.message).toBe('Hello, Jane!')
    expect(body.data.greeting).toBe('Hello, Jane!')
    expect(body.meta.feature).toBe('hello-world')
    expect(body.meta.request_id).toBeDefined()
    expect(body.meta.duration_ms).toBeDefined()
  })

  test('returns 404 for unknown routes', async () => {
    const res = await fetch(`${baseUrl}/api/nonexistent`)
    const body = await res.json()

    expect(res.status).toBe(404)
    expect(body.message).toBe('Not found')
  })

  test('returns 405 for wrong HTTP method', async () => {
    const res = await fetch(`${baseUrl}/api/hello`, { method: 'DELETE' })
    const body = await res.json()

    expect(res.status).toBe(405)
    expect(body.message).toBe('Method not allowed')
  })

  test('returns proper content-type header', async () => {
    const res = await fetch(`${baseUrl}/api/hello`)

    expect(res.headers.get('content-type')).toContain('application/json')
  })

  test('handles feature with no input (defaults)', async () => {
    const res = await fetch(`${baseUrl}/api/hello`)
    const body = await res.json()

    expect(res.status).toBe(200)
    expect(body.message).toBe('Hello, World!')
  })
})
```

**Step 2: Run test to verify it fails**

```bash
bun test tests/manifest/server.test.ts
```

**Step 3: Write the implementation**

```typescript
// manifest/server.ts

/**
 * Manifest HTTP server. Built on Bun.serve().
 *
 * This is the entry point that ties the framework together:
 *   1. Scans features/ directory
 *   2. Builds a router from feature definitions
 *   3. Starts a Bun HTTP server
 *   4. For each request: matches route → validates input → runs handle() → returns envelope
 *
 * This file is ~100 lines. An agent can read it end-to-end in seconds.
 */

import { scanFeatures } from './scanner'
import { createRouter } from './router'
import { validateInput } from './validator'
import { toEnvelope, createResultHelpers } from './envelope'
import type { FeatureResult } from './feature'
import path from 'path'

export interface ManifestServerOptions {
  /** Root directory of the Manifest project. */
  projectDir: string

  /** Port to listen on. 0 for random available port. */
  port?: number
}

export interface ManifestServer {
  /** The port the server is listening on. */
  port: number

  /** Stop the server. */
  stop(): void
}

export async function createManifestServer(
  options: ManifestServerOptions,
): Promise<ManifestServer> {
  const featuresDir = path.join(options.projectDir, 'features')
  const registry = await scanFeatures(featuresDir)
  const router = createRouter(registry)

  const server = Bun.serve({
    port: options.port ?? 8080,

    async fetch(req: Request): Promise<Response> {
      const startTime = performance.now()
      const requestId = `req_${crypto.randomUUID().slice(0, 16)}`
      const url = new URL(req.url)
      const method = req.method
      const pathname = url.pathname

      // Match route
      const match = router.match(method, pathname)

      if (!match) {
        const isWrongMethod = router.isMethodNotAllowed(method, pathname)
        const status = isWrongMethod ? 405 : 404
        const message = isWrongMethod ? 'Method not allowed' : 'Not found'
        const durationMs = Math.round(performance.now() - startTime)

        return Response.json(
          {
            status,
            message,
            meta: { request_id: requestId, duration_ms: durationMs },
          },
          { status },
        )
      }

      const { feature, params } = match

      // Parse input from query params, body, and path params
      let inputData: Record<string, unknown> = { ...params }

      // Query params
      for (const [key, value] of url.searchParams.entries()) {
        inputData[key] = value
      }

      // JSON body (for POST, PUT, PATCH)
      if (['POST', 'PUT', 'PATCH'].includes(method)) {
        try {
          const contentType = req.headers.get('content-type') ?? ''
          if (contentType.includes('application/json')) {
            const body = await req.json()
            if (typeof body === 'object' && body !== null) {
              inputData = { ...inputData, ...body }
            }
          }
        } catch {
          // Invalid JSON - will be caught by validation if fields are required
        }
      }

      // Validate input
      const validationErrors = validateInput(feature.input, inputData)
      if (Object.keys(validationErrors).length > 0) {
        const durationMs = Math.round(performance.now() - startTime)
        const result: FeatureResult = {
          success: false,
          status: 422,
          message: 'Validation failed',
          data: null,
          errors: validationErrors,
        }
        return Response.json(
          toEnvelope(result, { featureName: feature.name, requestId, durationMs }),
          { status: 422 },
        )
      }

      // Execute feature
      try {
        const { ok, fail } = createResultHelpers()
        const result = await feature.handle({
          input: inputData,
          ok,
          fail,
        })

        const durationMs = Math.round(performance.now() - startTime)
        return Response.json(
          toEnvelope(result, { featureName: feature.name, requestId, durationMs }),
          { status: result.status },
        )
      } catch (err) {
        const durationMs = Math.round(performance.now() - startTime)
        const message = err instanceof Error ? err.message : 'Internal server error'
        return Response.json(
          {
            status: 500,
            message,
            meta: {
              feature: feature.name,
              request_id: requestId,
              duration_ms: durationMs,
            },
          },
          { status: 500 },
        )
      }
    },
  })

  return {
    port: server.port,
    stop() {
      server.stop()
    },
  }
}
```

**Step 4: Run test to verify it passes**

```bash
bun test tests/manifest/server.test.ts
```

Expected: 5 tests, all PASS.

**Step 5: Commit**

```bash
git add manifest/server.ts tests/manifest/server.test.ts
git commit -m "feat: Manifest HTTP server on Bun.serve() with routing, validation, and envelopes"
```

---

## Task 9: Framework Index (`manifest/index.ts`)

The barrel export that re-exports everything from the framework. This is what features import from.

**Files:**
- Create: `manifest/index.ts`
- Modify: `features/HelloWorld.ts` (update imports to use barrel)

**Step 1: Create the barrel export**

```typescript
// manifest/index.ts

/**
 * Manifest Framework
 *
 * This is the barrel export for the framework. Features import from here:
 *
 *   import { defineFeature, t } from '../manifest'
 *
 * This file re-exports everything a feature needs. An agent looking at this
 * file sees the entire public API of the framework at a glance.
 */

export { defineFeature } from './feature'
export type { FeatureDef, FeatureResult, HandleContext, FeatureOptions } from './feature'

export { t } from './types'
export type { FieldDef, InputSchemaDef, StringFieldDef, IntegerFieldDef, NumberFieldDef, BooleanFieldDef, ArrayFieldDef } from './types'

export { validateInput } from './validator'

export { createRouter } from './router'
export type { Router, RouteMatch } from './router'

export { scanFeatures } from './scanner'
export type { FeatureRegistry } from './scanner'

export { toEnvelope, createResultHelpers } from './envelope'
export type { ResponseEnvelope } from './envelope'

export { createManifestServer } from './server'
export type { ManifestServer, ManifestServerOptions } from './server'
```

**Step 2: Update HelloWorld.ts to use barrel import**

```typescript
// features/HelloWorld.ts
import { defineFeature, t } from '../manifest'

export default defineFeature({
  name: 'hello-world',
  description: `A simple greeting endpoint. Returns a hello message with the
                provided name, or "World" if no name is given. This is the
                default demo feature that ships with every Manifest project.`,
  route: ['GET', '/api/hello'],
  authentication: 'none',
  sideEffects: [],
  errorCases: [],

  input: {
    name: t.string({
      description: 'The name to greet. Defaults to "World" if not provided.',
      required: false,
      maxLength: 100,
    }),
  },

  async handle({ input, ok }) {
    const name = (input as Record<string, unknown>).name ?? 'World'
    return ok(`Hello, ${name}!`, {
      data: { greeting: `Hello, ${name}!` },
    })
  },
})
```

**Step 3: Update index.ts entry point**

```typescript
// index.ts
import { createManifestServer } from './manifest'

const server = await createManifestServer({
  projectDir: import.meta.dir,
  port: Number(Bun.env.PORT ?? 8080),
})

console.log(`🔧 Manifest server running on http://localhost:${server.port}`)
console.log(`   Production is our dev environment.`)
```

**Step 4: Run all tests to make sure nothing broke**

```bash
bun test
```

Expected: All tests pass.

**Step 5: Verify the server runs end-to-end**

```bash
bun index.ts &
sleep 1
curl -s http://localhost:8080/api/hello?name=Agent | jq .
kill %1
```

Expected: JSON response with greeting.

**Step 6: Commit**

```bash
git add manifest/index.ts features/HelloWorld.ts index.ts
git commit -m "feat: barrel exports and working entry point"
```

---

## Task 10: Testing Client (`manifest/testing.ts`)

A test helper that lets tests call features by name without starting an HTTP server.

**Files:**
- Create: `manifest/testing.ts`
- Create: `tests/HelloWorld.test.ts` (the app-level test, not framework-level)

**Step 1: Write the app-level test first (defines the API we want)**

```typescript
// tests/HelloWorld.test.ts
import { describe, test, expect } from 'bun:test'
import { createTestClient } from '../manifest/testing'
import path from 'path'

describe('hello-world', () => {
  const client = createTestClient({
    featuresDir: path.resolve(__dirname, '../features'),
  })

  test('greets by name', async () => {
    const result = await client.call('hello-world', { name: 'Jane' })

    expect(result.status).toBe(200)
    expect(result.message).toBe('Hello, Jane!')
    expect(result.data.greeting).toBe('Hello, Jane!')
  })

  test('greets World by default', async () => {
    const result = await client.call('hello-world', {})

    expect(result.status).toBe(200)
    expect(result.message).toBe('Hello, World!')
  })

  test('returns error for unknown feature', async () => {
    await expect(client.call('nonexistent', {})).rejects.toThrow('Feature "nonexistent" not found')
  })
})
```

**Step 2: Write the testing client**

```typescript
// manifest/testing.ts

/**
 * Test client for Manifest features.
 *
 * Calls features directly by name without starting an HTTP server.
 * Input is passed directly, validation runs, handle() executes.
 *
 * Usage in tests:
 *   const client = createTestClient({ featuresDir: './features' })
 *   const result = await client.call('user-registration', { email: '...' })
 *   expect(result.status).toBe(201)
 */

import { scanFeatures } from './scanner'
import { validateInput } from './validator'
import { createResultHelpers } from './envelope'
import type { FeatureResult } from './feature'
import type { FeatureRegistry } from './scanner'

export interface TestResult {
  success: boolean
  status: number
  message: string
  data: any
  errors: Record<string, string>
}

export interface TestClient {
  /** Call a feature by name with the given input data. */
  call(featureName: string, input: Record<string, unknown>): Promise<TestResult>

  /** Get the feature registry (for inspection in tests). */
  getRegistry(): FeatureRegistry
}

export function createTestClient(options: {
  featuresDir: string
}): TestClient {
  let registryPromise: Promise<FeatureRegistry> | null = null

  async function getRegistry(): Promise<FeatureRegistry> {
    if (!registryPromise) {
      registryPromise = scanFeatures(options.featuresDir)
    }
    return registryPromise
  }

  return {
    async call(featureName: string, input: Record<string, unknown>): Promise<TestResult> {
      const registry = await getRegistry()
      const feature = registry[featureName]

      if (!feature) {
        throw new Error(`Feature "${featureName}" not found in ${options.featuresDir}`)
      }

      // Validate input
      const validationErrors = validateInput(feature.input, input)
      if (Object.keys(validationErrors).length > 0) {
        return {
          success: false,
          status: 422,
          message: 'Validation failed',
          data: null,
          errors: validationErrors,
        }
      }

      // Execute
      const { ok, fail } = createResultHelpers()
      const result = await feature.handle({ input, ok, fail })

      return {
        success: result.success,
        status: result.status,
        message: result.message,
        data: result.data,
        errors: result.errors,
      }
    },

    getRegistry() {
      return getRegistry()
    },
  }
}
```

**Step 3: Run tests**

```bash
bun test tests/HelloWorld.test.ts
```

Expected: 3 tests, all PASS.

**Step 4: Run ALL tests**

```bash
bun test
```

Expected: All tests pass across all test files.

**Step 5: Commit**

```bash
git add manifest/testing.ts tests/HelloWorld.test.ts
git commit -m "feat: test client for calling features by name without HTTP"
```

---

## Task 11: CLI - Serve Command (`manifest/cli/`)

The `bun manifest serve` command and CLI framework.

**Files:**
- Create: `manifest/cli/index.ts`
- Create: `manifest/cli/serve.ts`

**Step 1: Write the CLI entry point**

```typescript
// manifest/cli/index.ts

/**
 * Manifest CLI entry point.
 *
 * Usage:
 *   bun manifest/cli/index.ts serve
 *   bun manifest/cli/index.ts index
 *   bun manifest/cli/index.ts check
 *   bun manifest/cli/index.ts make:feature <Name>
 *
 * Or via package.json script:
 *   bun run manifest serve
 *
 * This CLI is intentionally simple. No commander.js, no yargs.
 * Just process.argv parsing. An agent can read the entire CLI in minutes.
 */

const args = process.argv.slice(2)
const command = args[0]

if (!command) {
  console.log(`
Manifest CLI - Production is our dev environment.

Usage:
  bun manifest serve [--port=8080]     Start the development server
  bun manifest index                    Rebuild MANIFEST.md
  bun manifest check                    Validate conventions
  bun manifest make:feature <Name>      Scaffold a new feature

`)
  process.exit(0)
}

switch (command) {
  case 'serve': {
    const { serve } = await import('./serve')
    await serve(args.slice(1))
    break
  }
  case 'index': {
    const { indexManifest } = await import('./indexManifest')
    await indexManifest(args.slice(1))
    break
  }
  case 'check': {
    const { check } = await import('./check')
    const exitCode = await check(args.slice(1))
    process.exit(exitCode)
    break
  }
  case 'make:feature': {
    const { makeFeature } = await import('./makeFeature')
    await makeFeature(args.slice(1))
    break
  }
  default:
    console.error(`Unknown command: ${command}`)
    process.exit(1)
}
```

**Step 2: Write the serve command**

```typescript
// manifest/cli/serve.ts

/**
 * Start the Manifest development server.
 *
 * Usage: bun manifest serve [--port=8080] [--host=0.0.0.0]
 *
 * Starts Bun.serve() with the project's features loaded.
 * In development, run with `bun --hot manifest/cli/index.ts serve` for hot reload.
 */

import { createManifestServer } from '../server'
import path from 'path'

export async function serve(args: string[]): Promise<void> {
  const projectDir = process.cwd()
  let port = 8080
  let host = '0.0.0.0'

  for (const arg of args) {
    if (arg.startsWith('--port=')) {
      port = parseInt(arg.slice(7), 10)
    }
    if (arg.startsWith('--host=')) {
      host = arg.slice(7)
    }
  }

  const server = await createManifestServer({
    projectDir,
    port,
  })

  console.log(``)
  console.log(`  Manifest server running on http://${host}:${server.port}`)
  console.log(`  Production is our dev environment.`)
  console.log(``)
  console.log(`  Tip: Run with 'bun --hot' for live reload:`)
  console.log(`    bun --hot manifest/cli/index.ts serve`)
  console.log(``)
}
```

**Step 3: Test manually**

```bash
bun manifest/cli/index.ts serve --port=3000 &
sleep 1
curl -s http://localhost:3000/api/hello?name=CLI | jq .
kill %1
```

Expected: JSON response.

**Step 4: Commit**

```bash
git add manifest/cli/index.ts manifest/cli/serve.ts
git commit -m "feat: CLI with serve command"
```

---

## Task 12: CLI - Index Command (generates MANIFEST.md)

**Files:**
- Create: `manifest/cli/indexManifest.ts`

**Step 1: Write the implementation**

```typescript
// manifest/cli/indexManifest.ts

/**
 * Rebuild MANIFEST.md from the current codebase state.
 *
 * Usage: bun manifest index
 *
 * Scans features/, schemas/, services/, and commands/ directories.
 * Generates a MANIFEST.md that serves as the agent's entry point
 * to the codebase. This file should be committed to git.
 */

import { scanFeatures } from '../scanner'
import path from 'path'
import { readdirSync, existsSync } from 'fs'

export async function indexManifest(_args: string[]): Promise<void> {
  const projectDir = process.cwd()

  // Scan features
  const registry = await scanFeatures(path.join(projectDir, 'features'))
  const features = Object.values(registry)

  // Count other directories
  const schemaCount = countFiles(path.join(projectDir, 'schemas'), '.ts')
  const serviceCount = countFiles(path.join(projectDir, 'services'), '.ts')
  const commandCount = countFiles(path.join(projectDir, 'commands'), '.ts')

  // Build MANIFEST.md
  let md = `# Manifest: ${path.basename(projectDir)}\n\n`

  md += `## System\n`
  md += `- Runtime: Bun ${Bun.version}, TypeScript, Manifest 0.1.x\n`
  md += `- Generated: ${new Date().toISOString().slice(0, 10)}\n\n`

  md += `## Architecture\n`
  md += `This is a Manifest application. All behavior lives in feature files.\n`
  md += `- features/ - One file per application behavior (${features.length} features)\n`
  md += `- schemas/ - Drizzle ORM table definitions (${schemaCount} schemas)\n`
  md += `- services/ - Shared services (${serviceCount} services)\n`
  md += `- commands/ - CLI commands (${commandCount} commands)\n\n`

  md += `## Conventions\n`
  md += `- NEVER use decorator-based patterns. Features are defined with defineFeature().\n`
  md += `- NEVER create event listeners or middleware. Side effects go in the feature's handle() function.\n`
  md += `- NEVER scatter one behavior across multiple files. One feature = one file.\n`
  md += `- Every input field MUST have a description.\n`
  md += `- Features MUST declare all side effects in the feature definition.\n`
  md += `- Schema fields MUST have JSDoc descriptions.\n`
  md += `- All dependencies MUST be explicit imports. No global state, no service locators.\n\n`

  md += `## Feature Index\n`
  md += `| Name | Route | Type | Description |\n`
  md += `|------|-------|------|-------------|\n`

  for (const feature of features) {
    const route = feature.route.length > 0
      ? `${feature.route[0]} ${feature.route[1]}`
      : (feature.trigger ?? 'n/a')
    const desc = feature.description.replace(/\s+/g, ' ').slice(0, 80)
    md += `| ${feature.name} | ${route} | ${feature.type} | ${desc} |\n`
  }

  md += `\n## Known Issues\n`
  md += `- None currently.\n\n`

  md += `## Recent Changes\n`

  // Preserve existing recent changes if MANIFEST.md exists
  const manifestPath = path.join(projectDir, 'MANIFEST.md')
  if (existsSync(manifestPath)) {
    const existing = await Bun.file(manifestPath).text()
    const changesMatch = existing.match(/## Recent Changes\n([\s\S]*)$/)
    if (changesMatch) {
      md += changesMatch[1].trim() + '\n'
      // Add regeneration entry
      md += `- ${new Date().toISOString().slice(0, 10)}: MANIFEST.md regenerated by \`bun manifest index\`\n`
    }
  } else {
    md += `- ${new Date().toISOString().slice(0, 10)}: MANIFEST.md generated\n`
  }

  await Bun.write(manifestPath, md)
  console.log(`\n  ✓ MANIFEST.md generated with ${features.length} features indexed.\n`)
}

function countFiles(dir: string, ext: string): number {
  try {
    return readdirSync(dir).filter((f) => f.endsWith(ext) && !f.endsWith('.test.ts')).length
  } catch {
    return 0
  }
}
```

**Step 2: Test manually**

```bash
bun manifest/cli/index.ts index
cat MANIFEST.md
```

Expected: MANIFEST.md generated with hello-world feature in the index.

**Step 3: Commit**

```bash
git add manifest/cli/indexManifest.ts
git commit -m "feat: index command generates MANIFEST.md from codebase"
```

---

## Task 13: CLI - Check Command

**Files:**
- Create: `manifest/cli/check.ts`

**Step 1: Write the implementation**

```typescript
// manifest/cli/check.ts

/**
 * Validate that the project follows Manifest conventions.
 *
 * Usage: bun manifest check
 *
 * Checks:
 *   - Every feature has a description
 *   - Every feature has declared side effects (can be empty array)
 *   - Every feature with type 'request' has a route
 *   - Every feature has a test file
 *   - MANIFEST.md exists
 *   - All routes are unique
 *   - Every input field has a description
 */

import { scanFeatures } from '../scanner'
import path from 'path'
import { existsSync } from 'fs'

export async function check(_args: string[]): Promise<number> {
  const projectDir = process.cwd()
  const issues: string[] = []
  const passes: string[] = []

  // Scan features
  const registry = await scanFeatures(path.join(projectDir, 'features'))
  const features = Object.entries(registry)

  // Check each feature
  const routes = new Map<string, string>()

  for (const [name, feature] of features) {
    // Description
    if (!feature.description || feature.description.trim().length === 0) {
      issues.push(`Feature '${name}' has no description.`)
    }

    // Side effects declared
    if (!feature.sideEffects) {
      issues.push(`Feature '${name}' is missing sideEffects declaration (can be empty array).`)
    }

    // Route for request types
    if (feature.type === 'request' && feature.route.length === 0) {
      issues.push(`Feature '${name}' is type 'request' but has no route.`)
    }

    // Input field descriptions
    for (const [fieldName, fieldDef] of Object.entries(feature.input)) {
      if (!fieldDef.description || fieldDef.description.trim().length === 0) {
        issues.push(`Feature '${name}' input field '${fieldName}' has no description.`)
      }
    }

    // Test file exists
    // Try multiple naming conventions
    const testPaths = [
      path.join(projectDir, 'tests', `${pascalCase(name)}.test.ts`),
      path.join(projectDir, 'tests', `${name}.test.ts`),
    ]
    const hasTest = testPaths.some((p) => existsSync(p))
    if (!hasTest) {
      issues.push(`Feature '${name}' has no test file.`)
    }

    // Route uniqueness
    if (feature.route.length > 0) {
      const routeKey = `${feature.route[0]} ${feature.route[1]}`
      if (routes.has(routeKey)) {
        issues.push(`Duplicate route '${routeKey}' in features '${routes.get(routeKey)}' and '${name}'.`)
      }
      routes.set(routeKey, name)
    }
  }

  // MANIFEST.md exists
  if (existsSync(path.join(projectDir, 'MANIFEST.md'))) {
    passes.push('MANIFEST.md exists.')
  } else {
    issues.push('MANIFEST.md does not exist. Run `bun manifest index` to generate it.')
  }

  // All routes unique
  passes.push('All routes are unique.')

  // Output
  console.log('')
  for (const issue of issues) {
    console.log(`  \x1b[31m✗\x1b[0m ${issue}`)
  }
  for (const pass of passes) {
    console.log(`  \x1b[32m✓\x1b[0m ${pass}`)
  }
  console.log('')

  if (issues.length > 0) {
    console.log(`  ${issues.length} issue(s) found.\n`)
    return 1
  }

  console.log(`  All checks passed.\n`)
  return 0
}

function pascalCase(kebab: string): string {
  return kebab
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('')
}
```

**Step 2: Test manually**

```bash
bun manifest/cli/index.ts check
```

Expected: Shows issues (like missing test files) and passes.

**Step 3: Commit**

```bash
git add manifest/cli/check.ts
git commit -m "feat: check command validates Manifest conventions"
```

---

## Task 14: CLI - make:feature Command

**Files:**
- Create: `manifest/cli/makeFeature.ts`

**Step 1: Write the implementation**

```typescript
// manifest/cli/makeFeature.ts

/**
 * Scaffold a new feature file.
 *
 * Usage: bun manifest make:feature UserRegistration [--route="POST /api/users"] [--auth=none]
 *
 * Generates features/<Name>.ts with the correct structure, imports, and TODO markers.
 */

import path from 'path'
import { existsSync } from 'fs'

export async function makeFeature(args: string[]): Promise<void> {
  const projectDir = process.cwd()
  const className = args[0]

  if (!className) {
    console.error('  Usage: bun manifest make:feature <ClassName> [--route="METHOD /path"] [--auth=none|required]')
    process.exit(1)
  }

  // Parse options
  let route = ''
  let auth = 'required'

  for (const arg of args.slice(1)) {
    if (arg.startsWith('--route=')) route = arg.slice(8).replace(/"/g, '')
    if (arg.startsWith('--auth=')) auth = arg.slice(7)
  }

  // Convert PascalCase to kebab-case
  const kebabName = className
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .toLowerCase()

  // Build route line
  let routeLine = `route: ['GET', '/api/${kebabName}'],`
  if (route) {
    const [method, ...pathParts] = route.split(' ')
    routeLine = `route: ['${method.toUpperCase()}', '${pathParts.join(' ')}'],`
  }

  const code = `// features/${className}.ts
import { defineFeature, t } from '../manifest'

export default defineFeature({
  name: '${kebabName}',
  description: \`TODO: Describe what this feature does. Be verbose - this is read by agents.
                Write 2-3 sentences explaining the purpose, behavior, and any important context.\`,
  ${routeLine}
  authentication: '${auth}',
  sideEffects: [
    // TODO: List ALL side effects (database writes, emails sent, API calls made, etc.)
    // Example: 'Inserts one row into users table',
    // Example: 'Sends welcome email via mailer service',
  ],
  errorCases: [
    // TODO: List ALL error cases with HTTP status codes.
    // Example: '409 - Email already registered',
    // Example: '422 - Validation failed',
  ],

  input: {
    // TODO: Define input fields. Every field MUST have a description.
    // Example:
    // email: t.string({ description: 'User email address.', required: true, format: 'email' }),
  },

  async handle({ input, ok, fail }) {
    // TODO: Implement feature logic.
    // Use ok() for success: return ok('Message', { data: {...}, status: 200 })
    // Use fail() for errors: return fail('Error message', 409)

    return ok('${className} executed')
  },
})
`

  const featuresDir = path.join(projectDir, 'features')
  const filePath = path.join(featuresDir, `${className}.ts`)

  if (existsSync(filePath)) {
    console.error(`\n  Feature already exists: features/${className}.ts\n`)
    process.exit(1)
  }

  await Bun.write(filePath, code)
  console.log(`\n  ✓ Created features/${className}.ts`)
  console.log(`  ✓ Run 'bun manifest check' to validate.\n`)
}
```

**Step 2: Test manually**

```bash
bun manifest/cli/index.ts make:feature CreatePost --route="POST /api/posts" --auth=required
cat features/CreatePost.ts
rm features/CreatePost.ts
```

Expected: Properly scaffolded feature file.

**Step 3: Commit**

```bash
git add manifest/cli/makeFeature.ts
git commit -m "feat: make:feature scaffolding command"
```

---

## Task 15: Config Files and Final Assembly

Create the config files, run all tests, generate MANIFEST.md, and verify everything works end-to-end.

**Files:**
- Create: `config/manifest.ts`
- Create: `config/database.ts`

**Step 1: Create config files**

```typescript
// config/manifest.ts

/**
 * Manifest application configuration.
 * Flat, typed, no nesting. Every value is visible and greppable.
 */
export default {
  appName: 'manifest-app',
  appUrl: Bun.env.APP_URL ?? 'http://localhost:8080',
  debug: Bun.env.NODE_ENV !== 'production',

  // API response settings
  includeMetaInResponses: true,
  includeDurationInMeta: true,

  // Rate limiting (not yet implemented)
  rateLimitDriver: 'memory' as const,
  rateLimitPrefix: 'manifest:',

  // Real-time (not yet implemented)
  sseHeartbeatSeconds: 15,
  sseMaxConnectionSeconds: 300,
}
```

```typescript
// config/database.ts

/**
 * Database configuration.
 * Uses Bun.env for environment-specific values with safe defaults.
 */
export default {
  host: Bun.env.DB_HOST ?? 'localhost',
  port: Number(Bun.env.DB_PORT ?? 5432),
  database: Bun.env.DB_NAME ?? 'manifest',
  user: Bun.env.DB_USER ?? 'manifest',
  password: Bun.env.DB_PASSWORD ?? '',
}
```

**Step 2: Update package.json scripts**

Ensure the `manifest` script works:

```json
{
  "scripts": {
    "dev": "bun --hot index.ts",
    "start": "bun index.ts",
    "test": "bun test",
    "manifest": "bun manifest/cli/index.ts"
  }
}
```

**Step 3: Run ALL tests**

```bash
bun test
```

Expected: All tests pass.

**Step 4: Generate MANIFEST.md**

```bash
bun run manifest index
```

**Step 5: Run check**

```bash
bun run manifest check
```

**Step 6: Start the server and test end-to-end**

```bash
bun run dev &
sleep 1
curl -s http://localhost:8080/api/hello | jq .
curl -s http://localhost:8080/api/hello?name=Agent | jq .
curl -s http://localhost:8080/api/nonexistent | jq .
curl -s -X DELETE http://localhost:8080/api/hello | jq .
kill %1
```

Expected: All responses are proper JSON envelopes.

**Step 7: Commit everything**

```bash
git add -A
git commit -m "feat: complete Manifest framework MVP - production is our dev environment"
```

---

## Summary

After completing all 15 tasks, the project contains:

### Framework (`manifest/` - ~600 lines of TypeScript)

| File | Lines | Purpose |
|------|-------|---------|
| `types.ts` | ~90 | Input type builders (`t.string()`, `t.integer()`, etc.) |
| `validator.ts` | ~80 | Input validation against schemas |
| `feature.ts` | ~70 | `defineFeature()` and feature types |
| `envelope.ts` | ~50 | Response envelope formatting |
| `scanner.ts` | ~40 | Feature directory scanner |
| `router.ts` | ~70 | HTTP route matching |
| `server.ts` | ~100 | Bun.serve() wrapper tying it all together |
| `testing.ts` | ~50 | Test client for calling features by name |
| `index.ts` | ~20 | Barrel exports |
| `cli/` | ~200 | serve, index, check, make:feature commands |
| **Total** | **~770** | **Entire framework an agent can read in minutes** |

### Application

| Component | Files |
|-----------|-------|
| `features/HelloWorld.ts` | Demo feature |
| `config/manifest.ts` | App config |
| `config/database.ts` | DB config |
| `tests/HelloWorld.test.ts` | Demo test |
| `MANIFEST.md` | Generated index |

### What's NOT included (future tasks)

- Drizzle ORM integration (schema files, migrations, database queries in features)
- Authentication middleware
- Rate limiting
- SSE stream features
- Event-triggered features
- `make:schema`, `make:test` commands
- Docker setup
- Agent sidecar integration
- Error tracker integration
